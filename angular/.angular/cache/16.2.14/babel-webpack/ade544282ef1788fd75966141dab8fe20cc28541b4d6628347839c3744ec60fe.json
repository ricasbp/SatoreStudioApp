{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/tmart/Desktop/Dissertacao/TourOfHeroes/tour-of-heroes-osc.js/tour-of-heroes/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar debugFactory = require('debug');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar debugFactory__default = /*#__PURE__*/_interopDefaultLegacy(debugFactory);\nconst debug = debugFactory__default[\"default\"]('serialport/binding-mock');\nlet ports = {};\nlet serialNumber = 0;\nfunction resolveNextTick() {\n  return new Promise(resolve => process.nextTick(() => resolve()));\n}\nclass CanceledError extends Error {\n  constructor(message) {\n    super(message);\n    this.canceled = true;\n  }\n}\nconst MockBinding = {\n  reset() {\n    ports = {};\n    serialNumber = 0;\n  },\n  // Create a mock port\n  createPort(path, options = {}) {\n    serialNumber++;\n    const optWithDefaults = Object.assign({\n      echo: false,\n      record: false,\n      manufacturer: 'The J5 Robotics Company',\n      vendorId: undefined,\n      productId: undefined,\n      maxReadSize: 1024\n    }, options);\n    ports[path] = {\n      data: Buffer.alloc(0),\n      echo: optWithDefaults.echo,\n      record: optWithDefaults.record,\n      readyData: optWithDefaults.readyData,\n      maxReadSize: optWithDefaults.maxReadSize,\n      info: {\n        path,\n        manufacturer: optWithDefaults.manufacturer,\n        serialNumber: `${serialNumber}`,\n        pnpId: undefined,\n        locationId: undefined,\n        vendorId: optWithDefaults.vendorId,\n        productId: optWithDefaults.productId\n      }\n    };\n    debug(serialNumber, 'created port', JSON.stringify({\n      path,\n      opt: options\n    }));\n  },\n  list() {\n    return _asyncToGenerator(function* () {\n      debug(null, 'list');\n      return Object.values(ports).map(port => port.info);\n    })();\n  },\n  open(options) {\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (!options || typeof options !== 'object' || Array.isArray(options)) {\n        throw new TypeError('\"options\" is not an object');\n      }\n      if (!options.path) {\n        throw new TypeError('\"path\" is not a valid port');\n      }\n      if (!options.baudRate) {\n        throw new TypeError('\"baudRate\" is not a valid baudRate');\n      }\n      const openOptions = Object.assign({\n        dataBits: 8,\n        lock: true,\n        stopBits: 1,\n        parity: 'none',\n        rtscts: false,\n        xon: false,\n        xoff: false,\n        xany: false,\n        hupcl: true\n      }, options);\n      const {\n        path\n      } = openOptions;\n      debug(null, `open: opening path ${path}`);\n      const port = ports[path];\n      yield resolveNextTick();\n      if (!port) {\n        throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);\n      }\n      const serialNumber = port.info.serialNumber;\n      if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {\n        debug(serialNumber, 'open: Port is locked cannot open');\n        throw new Error('Port is locked cannot open');\n      }\n      debug(serialNumber, `open: opened path ${path}`);\n      port.openOpt = Object.assign({}, openOptions);\n      return new MockPortBinding(port, openOptions);\n    })();\n  }\n};\n/**\n * Mock bindings for pretend serialport access\n */\nclass MockPortBinding {\n  constructor(port, openOptions) {\n    this.port = port;\n    this.openOptions = openOptions;\n    this.pendingRead = null;\n    this.isOpen = true;\n    this.lastWrite = null;\n    this.recording = Buffer.alloc(0);\n    this.writeOperation = null; // in flight promise or null\n    this.serialNumber = port.info.serialNumber;\n    if (port.readyData) {\n      const data = port.readyData;\n      process.nextTick(() => {\n        if (this.isOpen) {\n          debug(this.serialNumber, 'emitting ready data');\n          this.emitData(data);\n        }\n      });\n    }\n  }\n  // Emit data on a mock port\n  emitData(data) {\n    if (!this.isOpen || !this.port) {\n      throw new Error('Port must be open to pretend to receive data');\n    }\n    const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);\n    debug(this.serialNumber, 'emitting data - pending read:', Boolean(this.pendingRead));\n    this.port.data = Buffer.concat([this.port.data, bufferData]);\n    if (this.pendingRead) {\n      process.nextTick(this.pendingRead);\n      this.pendingRead = null;\n    }\n  }\n  close() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      debug(_this.serialNumber, 'close');\n      if (!_this.isOpen) {\n        throw new Error('Port is not open');\n      }\n      const port = _this.port;\n      if (!port) {\n        throw new Error('already closed');\n      }\n      port.openOpt = undefined;\n      // reset data on close\n      port.data = Buffer.alloc(0);\n      debug(_this.serialNumber, 'port is closed');\n      _this.serialNumber = undefined;\n      _this.isOpen = false;\n      if (_this.pendingRead) {\n        _this.pendingRead(new CanceledError('port is closed'));\n      }\n    })();\n  }\n  read(buffer, offset, length) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!Buffer.isBuffer(buffer)) {\n        throw new TypeError('\"buffer\" is not a Buffer');\n      }\n      if (typeof offset !== 'number' || isNaN(offset)) {\n        throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n      }\n      if (typeof length !== 'number' || isNaN(length)) {\n        throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n      }\n      if (buffer.length < offset + length) {\n        throw new Error('buffer is too small');\n      }\n      if (!_this2.isOpen) {\n        throw new Error('Port is not open');\n      }\n      debug(_this2.serialNumber, 'read', length, 'bytes');\n      yield resolveNextTick();\n      if (!_this2.isOpen || !_this2.port) {\n        throw new CanceledError('Read canceled');\n      }\n      if (_this2.port.data.length <= 0) {\n        return new Promise((resolve, reject) => {\n          _this2.pendingRead = err => {\n            if (err) {\n              return reject(err);\n            }\n            _this2.read(buffer, offset, length).then(resolve, reject);\n          };\n        });\n      }\n      const lengthToRead = _this2.port.maxReadSize > length ? length : _this2.port.maxReadSize;\n      const data = _this2.port.data.slice(0, lengthToRead);\n      const bytesRead = data.copy(buffer, offset);\n      _this2.port.data = _this2.port.data.slice(lengthToRead);\n      debug(_this2.serialNumber, 'read', bytesRead, 'bytes');\n      return {\n        bytesRead,\n        buffer\n      };\n    })();\n  }\n  write(buffer) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!Buffer.isBuffer(buffer)) {\n        throw new TypeError('\"buffer\" is not a Buffer');\n      }\n      if (!_this3.isOpen || !_this3.port) {\n        debug('write', 'error port is not open');\n        throw new Error('Port is not open');\n      }\n      debug(_this3.serialNumber, 'write', buffer.length, 'bytes');\n      if (_this3.writeOperation) {\n        throw new Error('Overlapping writes are not supported and should be queued by the serialport object');\n      }\n      _this3.writeOperation = _asyncToGenerator(function* () {\n        yield resolveNextTick();\n        if (!_this3.isOpen || !_this3.port) {\n          throw new Error('Write canceled');\n        }\n        const data = _this3.lastWrite = Buffer.from(buffer); // copy\n        if (_this3.port.record) {\n          _this3.recording = Buffer.concat([_this3.recording, data]);\n        }\n        if (_this3.port.echo) {\n          process.nextTick(() => {\n            if (_this3.isOpen) {\n              _this3.emitData(data);\n            }\n          });\n        }\n        _this3.writeOperation = null;\n        debug(_this3.serialNumber, 'writing finished');\n      })();\n      return _this3.writeOperation;\n    })();\n  }\n  update(options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof options !== 'object') {\n        throw TypeError('\"options\" is not an object');\n      }\n      if (typeof options.baudRate !== 'number') {\n        throw new TypeError('\"options.baudRate\" is not a number');\n      }\n      debug(_this4.serialNumber, 'update');\n      if (!_this4.isOpen || !_this4.port) {\n        throw new Error('Port is not open');\n      }\n      yield resolveNextTick();\n      if (_this4.port.openOpt) {\n        _this4.port.openOpt.baudRate = options.baudRate;\n      }\n    })();\n  }\n  set(options) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof options !== 'object') {\n        throw new TypeError('\"options\" is not an object');\n      }\n      debug(_this5.serialNumber, 'set');\n      if (!_this5.isOpen) {\n        throw new Error('Port is not open');\n      }\n      yield resolveNextTick();\n    })();\n  }\n  get() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      debug(_this6.serialNumber, 'get');\n      if (!_this6.isOpen) {\n        throw new Error('Port is not open');\n      }\n      yield resolveNextTick();\n      return {\n        cts: true,\n        dsr: false,\n        dcd: false\n      };\n    })();\n  }\n  getBaudRate() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      debug(_this7.serialNumber, 'getBaudRate');\n      if (!_this7.isOpen || !_this7.port) {\n        throw new Error('Port is not open');\n      }\n      yield resolveNextTick();\n      if (!((_a = _this7.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {\n        throw new Error('Internal Error');\n      }\n      return {\n        baudRate: _this7.port.openOpt.baudRate\n      };\n    })();\n  }\n  flush() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      debug(_this8.serialNumber, 'flush');\n      if (!_this8.isOpen || !_this8.port) {\n        throw new Error('Port is not open');\n      }\n      yield resolveNextTick();\n      _this8.port.data = Buffer.alloc(0);\n    })();\n  }\n  drain() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      debug(_this9.serialNumber, 'drain');\n      if (!_this9.isOpen) {\n        throw new Error('Port is not open');\n      }\n      yield _this9.writeOperation;\n      yield resolveNextTick();\n    })();\n  }\n}\nexports.CanceledError = CanceledError;\nexports.MockBinding = MockBinding;\nexports.MockPortBinding = MockPortBinding;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","debugFactory","_interopDefaultLegacy","e","debugFactory__default","debug","ports","serialNumber","resolveNextTick","Promise","resolve","process","nextTick","CanceledError","Error","constructor","message","canceled","MockBinding","reset","createPort","path","options","optWithDefaults","assign","echo","record","manufacturer","vendorId","undefined","productId","maxReadSize","data","Buffer","alloc","readyData","info","pnpId","locationId","JSON","stringify","opt","list","values","map","port","open","_a","Array","isArray","TypeError","baudRate","openOptions","dataBits","lock","stopBits","parity","rtscts","xon","xoff","xany","hupcl","openOpt","MockPortBinding","pendingRead","isOpen","lastWrite","recording","writeOperation","emitData","bufferData","isBuffer","from","Boolean","concat","close","_this","read","buffer","offset","length","_this2","isNaN","reject","err","then","lengthToRead","slice","bytesRead","copy","write","_this3","update","_this4","set","_this5","get","_this6","cts","dsr","dcd","getBaudRate","_this7","flush","_this8","drain","_this9"],"sources":["C:/Users/tmart/Desktop/Dissertacao/TourOfHeroes/tour-of-heroes-osc.js/tour-of-heroes/node_modules/@serialport/binding-mock/dist/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar debugFactory = require('debug');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debugFactory__default = /*#__PURE__*/_interopDefaultLegacy(debugFactory);\n\nconst debug = debugFactory__default[\"default\"]('serialport/binding-mock');\nlet ports = {};\nlet serialNumber = 0;\nfunction resolveNextTick() {\n    return new Promise(resolve => process.nextTick(() => resolve()));\n}\nclass CanceledError extends Error {\n    constructor(message) {\n        super(message);\n        this.canceled = true;\n    }\n}\nconst MockBinding = {\n    reset() {\n        ports = {};\n        serialNumber = 0;\n    },\n    // Create a mock port\n    createPort(path, options = {}) {\n        serialNumber++;\n        const optWithDefaults = Object.assign({ echo: false, record: false, manufacturer: 'The J5 Robotics Company', vendorId: undefined, productId: undefined, maxReadSize: 1024 }, options);\n        ports[path] = {\n            data: Buffer.alloc(0),\n            echo: optWithDefaults.echo,\n            record: optWithDefaults.record,\n            readyData: optWithDefaults.readyData,\n            maxReadSize: optWithDefaults.maxReadSize,\n            info: {\n                path,\n                manufacturer: optWithDefaults.manufacturer,\n                serialNumber: `${serialNumber}`,\n                pnpId: undefined,\n                locationId: undefined,\n                vendorId: optWithDefaults.vendorId,\n                productId: optWithDefaults.productId,\n            },\n        };\n        debug(serialNumber, 'created port', JSON.stringify({ path, opt: options }));\n    },\n    async list() {\n        debug(null, 'list');\n        return Object.values(ports).map(port => port.info);\n    },\n    async open(options) {\n        var _a;\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const { path } = openOptions;\n        debug(null, `open: opening path ${path}`);\n        const port = ports[path];\n        await resolveNextTick();\n        if (!port) {\n            throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);\n        }\n        const serialNumber = port.info.serialNumber;\n        if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {\n            debug(serialNumber, 'open: Port is locked cannot open');\n            throw new Error('Port is locked cannot open');\n        }\n        debug(serialNumber, `open: opened path ${path}`);\n        port.openOpt = Object.assign({}, openOptions);\n        return new MockPortBinding(port, openOptions);\n    },\n};\n/**\n * Mock bindings for pretend serialport access\n */\nclass MockPortBinding {\n    constructor(port, openOptions) {\n        this.port = port;\n        this.openOptions = openOptions;\n        this.pendingRead = null;\n        this.isOpen = true;\n        this.lastWrite = null;\n        this.recording = Buffer.alloc(0);\n        this.writeOperation = null; // in flight promise or null\n        this.serialNumber = port.info.serialNumber;\n        if (port.readyData) {\n            const data = port.readyData;\n            process.nextTick(() => {\n                if (this.isOpen) {\n                    debug(this.serialNumber, 'emitting ready data');\n                    this.emitData(data);\n                }\n            });\n        }\n    }\n    // Emit data on a mock port\n    emitData(data) {\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port must be open to pretend to receive data');\n        }\n        const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);\n        debug(this.serialNumber, 'emitting data - pending read:', Boolean(this.pendingRead));\n        this.port.data = Buffer.concat([this.port.data, bufferData]);\n        if (this.pendingRead) {\n            process.nextTick(this.pendingRead);\n            this.pendingRead = null;\n        }\n    }\n    async close() {\n        debug(this.serialNumber, 'close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const port = this.port;\n        if (!port) {\n            throw new Error('already closed');\n        }\n        port.openOpt = undefined;\n        // reset data on close\n        port.data = Buffer.alloc(0);\n        debug(this.serialNumber, 'port is closed');\n        this.serialNumber = undefined;\n        this.isOpen = false;\n        if (this.pendingRead) {\n            this.pendingRead(new CanceledError('port is closed'));\n        }\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        debug(this.serialNumber, 'read', length, 'bytes');\n        await resolveNextTick();\n        if (!this.isOpen || !this.port) {\n            throw new CanceledError('Read canceled');\n        }\n        if (this.port.data.length <= 0) {\n            return new Promise((resolve, reject) => {\n                this.pendingRead = err => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    this.read(buffer, offset, length).then(resolve, reject);\n                };\n            });\n        }\n        const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;\n        const data = this.port.data.slice(0, lengthToRead);\n        const bytesRead = data.copy(buffer, offset);\n        this.port.data = this.port.data.slice(lengthToRead);\n        debug(this.serialNumber, 'read', bytesRead, 'bytes');\n        return { bytesRead, buffer };\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (!this.isOpen || !this.port) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        debug(this.serialNumber, 'write', buffer.length, 'bytes');\n        if (this.writeOperation) {\n            throw new Error('Overlapping writes are not supported and should be queued by the serialport object');\n        }\n        this.writeOperation = (async () => {\n            await resolveNextTick();\n            if (!this.isOpen || !this.port) {\n                throw new Error('Write canceled');\n            }\n            const data = (this.lastWrite = Buffer.from(buffer)); // copy\n            if (this.port.record) {\n                this.recording = Buffer.concat([this.recording, data]);\n            }\n            if (this.port.echo) {\n                process.nextTick(() => {\n                    if (this.isOpen) {\n                        this.emitData(data);\n                    }\n                });\n            }\n            this.writeOperation = null;\n            debug(this.serialNumber, 'writing finished');\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (typeof options !== 'object') {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug(this.serialNumber, 'update');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        if (this.port.openOpt) {\n            this.port.openOpt.baudRate = options.baudRate;\n        }\n    }\n    async set(options) {\n        if (typeof options !== 'object') {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug(this.serialNumber, 'set');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n    }\n    async get() {\n        debug(this.serialNumber, 'get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        return {\n            cts: true,\n            dsr: false,\n            dcd: false,\n        };\n    }\n    async getBaudRate() {\n        var _a;\n        debug(this.serialNumber, 'getBaudRate');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {\n            throw new Error('Internal Error');\n        }\n        return {\n            baudRate: this.port.openOpt.baudRate,\n        };\n    }\n    async flush() {\n        debug(this.serialNumber, 'flush');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        this.port.data = Buffer.alloc(0);\n    }\n    async drain() {\n        debug(this.serialNumber, 'drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await resolveNextTick();\n    }\n}\n\nexports.CanceledError = CanceledError;\nexports.MockBinding = MockBinding;\nexports.MockPortBinding = MockPortBinding;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}