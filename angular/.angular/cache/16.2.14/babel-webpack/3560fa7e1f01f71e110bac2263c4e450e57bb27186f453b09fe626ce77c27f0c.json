{"ast":null,"code":"/*\n * osc.js: An Open Sound Control library for JavaScript that works in both the browser and Node.js\n *\n * Copyright 2014-2016, Colin Clark\n * Licensed under the MIT and GPL 3 licenses.\n */\n\n/* global require, module, process, Buffer, Long, util */\n\nvar osc = osc || {};\n(function () {\n  \"use strict\";\n\n  osc.SECS_70YRS = 2208988800;\n  osc.TWO_32 = 4294967296;\n  osc.defaults = {\n    metadata: false,\n    unpackSingleArgs: true\n  };\n\n  // Unsupported, non-API property.\n  osc.isCommonJS = typeof module !== \"undefined\" && module.exports ? true : false;\n\n  // Unsupported, non-API property.\n  osc.isNode = osc.isCommonJS && typeof window === \"undefined\";\n\n  // Unsupported, non-API property.\n  osc.isElectron = typeof process !== \"undefined\" && process.versions && process.versions.electron ? true : false;\n\n  // Unsupported, non-API property.\n  osc.isBufferEnv = osc.isNode || osc.isElectron;\n\n  // Unsupported, non-API function.\n  osc.isArray = function (obj) {\n    return obj && Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  // Unsupported, non-API function.\n  osc.isTypedArrayView = function (obj) {\n    return obj.buffer && obj.buffer instanceof ArrayBuffer;\n  };\n\n  // Unsupported, non-API function.\n  osc.isBuffer = function (obj) {\n    return osc.isBufferEnv && obj instanceof Buffer;\n  };\n\n  // Unsupported, non-API member.\n  osc.Long = typeof Long !== \"undefined\" ? Long : osc.isNode ? require(\"long\") : undefined;\n\n  // Unsupported, non-API member. Can be removed when supported versions\n  // of Node.js expose TextDecoder as a global, as in the browser.\n  osc.TextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\") : typeof util !== \"undefined\" && typeof (util.TextDecoder !== \"undefined\") ? new util.TextDecoder(\"utf-8\") : undefined;\n  osc.TextEncoder = typeof TextEncoder !== \"undefined\" ? new TextEncoder(\"utf-8\") : typeof util !== \"undefined\" && typeof (util.TextEncoder !== \"undefined\") ? new util.TextEncoder(\"utf-8\") : undefined;\n\n  /**\n   * Wraps the specified object in a DataView.\n   *\n   * @param {Array-like} obj the object to wrap in a DataView instance\n   * @return {DataView} the DataView object\n   */\n  // Unsupported, non-API function.\n  osc.dataView = function (obj, offset, length) {\n    if (obj.buffer) {\n      return new DataView(obj.buffer, offset, length);\n    }\n    if (obj instanceof ArrayBuffer) {\n      return new DataView(obj, offset, length);\n    }\n    return new DataView(new Uint8Array(obj), offset, length);\n  };\n\n  /**\n   * Takes an ArrayBuffer, TypedArray, DataView, Buffer, or array-like object\n   * and returns a Uint8Array view of it.\n   *\n   * Throws an error if the object isn't suitably array-like.\n   *\n   * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object\n   * @returns {Uint8Array} a typed array of octets\n   */\n  // Unsupported, non-API function.\n  osc.byteArray = function (obj) {\n    if (obj instanceof Uint8Array) {\n      return obj;\n    }\n    var buf = obj.buffer ? obj.buffer : obj;\n    if (!(buf instanceof ArrayBuffer) && (typeof buf.length === \"undefined\" || typeof buf === \"string\")) {\n      throw new Error(\"Can't wrap a non-array-like object as Uint8Array. Object was: \" + JSON.stringify(obj, null, 2));\n    }\n\n    // TODO gh-39: This is a potentially unsafe algorithm;\n    // if we're getting anything other than a TypedArrayView (such as a DataView),\n    // we really need to determine the range of the view it is viewing.\n    return new Uint8Array(buf);\n  };\n\n  /**\n   * Takes an ArrayBuffer, TypedArray, DataView, or array-like object\n   * and returns a native buffer object\n   * (i.e. in Node.js, a Buffer object and in the browser, a Uint8Array).\n   *\n   * Throws an error if the object isn't suitably array-like.\n   *\n   * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object\n   * @returns {Buffer|Uint8Array} a buffer object\n   */\n  // Unsupported, non-API function.\n  osc.nativeBuffer = function (obj) {\n    if (osc.isBufferEnv) {\n      return osc.isBuffer(obj) ? obj : Buffer.from(obj.buffer ? obj : new Uint8Array(obj));\n    }\n    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);\n  };\n\n  // Unsupported, non-API function\n  osc.copyByteArray = function (source, target, offset) {\n    if (osc.isTypedArrayView(source) && osc.isTypedArrayView(target)) {\n      target.set(source, offset);\n    } else {\n      var start = offset === undefined ? 0 : offset,\n        len = Math.min(target.length - offset, source.length);\n      for (var i = 0, j = start; i < len; i++, j++) {\n        target[j] = source[i];\n      }\n    }\n    return target;\n  };\n\n  /**\n   * Reads an OSC-formatted string.\n   *\n   * @param {DataView} dv a DataView containing the raw bytes of the OSC string\n   * @param {Object} offsetState an offsetState object used to store the current offset index\n   * @return {String} the JavaScript String that was read\n   */\n  osc.readString = function (dv, offsetState) {\n    var charCodes = [],\n      idx = offsetState.idx;\n    for (; idx < dv.byteLength; idx++) {\n      var charCode = dv.getUint8(idx);\n      if (charCode !== 0) {\n        charCodes.push(charCode);\n      } else {\n        idx++;\n        break;\n      }\n    }\n\n    // Round to the nearest 4-byte block.\n    idx = idx + 3 & ~0x03;\n    offsetState.idx = idx;\n    var decoder = osc.isBufferEnv ? osc.readString.withBuffer : osc.TextDecoder ? osc.readString.withTextDecoder : osc.readString.raw;\n    return decoder(charCodes);\n  };\n  osc.readString.raw = function (charCodes) {\n    // If no Buffer or TextDecoder, resort to fromCharCode\n    // This does not properly decode multi-byte Unicode characters.\n    var str = \"\";\n    var sliceSize = 10000;\n\n    // Processing the array in chunks so as not to exceed argument\n    // limit, see https://bugs.webkit.org/show_bug.cgi?id=80797\n    for (var i = 0; i < charCodes.length; i += sliceSize) {\n      str += String.fromCharCode.apply(null, charCodes.slice(i, i + sliceSize));\n    }\n    return str;\n  };\n  osc.readString.withTextDecoder = function (charCodes) {\n    var data = new Int8Array(charCodes);\n    return osc.TextDecoder.decode(data);\n  };\n  osc.readString.withBuffer = function (charCodes) {\n    return Buffer.from(charCodes).toString(\"utf-8\");\n  };\n\n  /**\n   * Writes a JavaScript string as an OSC-formatted string.\n   *\n   * @param {String} str the string to write\n   * @return {Uint8Array} a buffer containing the OSC-formatted string\n   */\n  osc.writeString = function (str) {\n    var encoder = osc.isBufferEnv ? osc.writeString.withBuffer : osc.TextEncoder ? osc.writeString.withTextEncoder : null,\n      terminated = str + \"\\u0000\",\n      encodedStr;\n    if (encoder) {\n      encodedStr = encoder(terminated);\n    }\n    var len = encoder ? encodedStr.length : terminated.length,\n      paddedLen = len + 3 & ~0x03,\n      arr = new Uint8Array(paddedLen);\n    for (var i = 0; i < len - 1; i++) {\n      var charCode = encoder ? encodedStr[i] : terminated.charCodeAt(i);\n      arr[i] = charCode;\n    }\n    return arr;\n  };\n  osc.writeString.withTextEncoder = function (str) {\n    return osc.TextEncoder.encode(str);\n  };\n  osc.writeString.withBuffer = function (str) {\n    return Buffer.from(str);\n  };\n\n  // Unsupported, non-API function.\n  osc.readPrimitive = function (dv, readerName, numBytes, offsetState) {\n    var val = dv[readerName](offsetState.idx, false);\n    offsetState.idx += numBytes;\n    return val;\n  };\n\n  // Unsupported, non-API function.\n  osc.writePrimitive = function (val, dv, writerName, numBytes, offset) {\n    offset = offset === undefined ? 0 : offset;\n    var arr;\n    if (!dv) {\n      arr = new Uint8Array(numBytes);\n      dv = new DataView(arr.buffer);\n    } else {\n      arr = new Uint8Array(dv.buffer);\n    }\n    dv[writerName](offset, val, false);\n    return arr;\n  };\n\n  /**\n   * Reads an OSC int32 (\"i\") value.\n   *\n   * @param {DataView} dv a DataView containing the raw bytes\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Number} the number that was read\n   */\n  osc.readInt32 = function (dv, offsetState) {\n    return osc.readPrimitive(dv, \"getInt32\", 4, offsetState);\n  };\n\n  /**\n   * Writes an OSC int32 (\"i\") value.\n   *\n   * @param {Number} val the number to write\n   * @param {DataView} [dv] a DataView instance to write the number into\n   * @param {Number} [offset] an offset into dv\n   */\n  osc.writeInt32 = function (val, dv, offset) {\n    return osc.writePrimitive(val, dv, \"setInt32\", 4, offset);\n  };\n\n  /**\n   * Reads an OSC int64 (\"h\") value.\n   *\n   * @param {DataView} dv a DataView containing the raw bytes\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Number} the number that was read\n   */\n  osc.readInt64 = function (dv, offsetState) {\n    var high = osc.readPrimitive(dv, \"getInt32\", 4, offsetState),\n      low = osc.readPrimitive(dv, \"getInt32\", 4, offsetState);\n    if (osc.Long) {\n      return new osc.Long(low, high);\n    } else {\n      return {\n        high: high,\n        low: low,\n        unsigned: false\n      };\n    }\n  };\n\n  /**\n   * Writes an OSC int64 (\"h\") value.\n   *\n   * @param {Number} val the number to write\n   * @param {DataView} [dv] a DataView instance to write the number into\n   * @param {Number} [offset] an offset into dv\n   */\n  osc.writeInt64 = function (val, dv, offset) {\n    var arr = new Uint8Array(8);\n    arr.set(osc.writePrimitive(val.high, dv, \"setInt32\", 4, offset), 0);\n    arr.set(osc.writePrimitive(val.low, dv, \"setInt32\", 4, offset + 4), 4);\n    return arr;\n  };\n\n  /**\n   * Reads an OSC float32 (\"f\") value.\n   *\n   * @param {DataView} dv a DataView containing the raw bytes\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Number} the number that was read\n   */\n  osc.readFloat32 = function (dv, offsetState) {\n    return osc.readPrimitive(dv, \"getFloat32\", 4, offsetState);\n  };\n\n  /**\n   * Writes an OSC float32 (\"f\") value.\n   *\n   * @param {Number} val the number to write\n   * @param {DataView} [dv] a DataView instance to write the number into\n   * @param {Number} [offset] an offset into dv\n   */\n  osc.writeFloat32 = function (val, dv, offset) {\n    return osc.writePrimitive(val, dv, \"setFloat32\", 4, offset);\n  };\n\n  /**\n   * Reads an OSC float64 (\"d\") value.\n   *\n   * @param {DataView} dv a DataView containing the raw bytes\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Number} the number that was read\n   */\n  osc.readFloat64 = function (dv, offsetState) {\n    return osc.readPrimitive(dv, \"getFloat64\", 8, offsetState);\n  };\n\n  /**\n   * Writes an OSC float64 (\"d\") value.\n   *\n   * @param {Number} val the number to write\n   * @param {DataView} [dv] a DataView instance to write the number into\n   * @param {Number} [offset] an offset into dv\n   */\n  osc.writeFloat64 = function (val, dv, offset) {\n    return osc.writePrimitive(val, dv, \"setFloat64\", 8, offset);\n  };\n\n  /**\n   * Reads an OSC 32-bit ASCII character (\"c\") value.\n   *\n   * @param {DataView} dv a DataView containing the raw bytes\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {String} a string containing the read character\n   */\n  osc.readChar32 = function (dv, offsetState) {\n    var charCode = osc.readPrimitive(dv, \"getUint32\", 4, offsetState);\n    return String.fromCharCode(charCode);\n  };\n\n  /**\n   * Writes an OSC 32-bit ASCII character (\"c\") value.\n   *\n   * @param {String} str the string from which the first character will be written\n   * @param {DataView} [dv] a DataView instance to write the character into\n   * @param {Number} [offset] an offset into dv\n   * @return {String} a string containing the read character\n   */\n  osc.writeChar32 = function (str, dv, offset) {\n    var charCode = str.charCodeAt(0);\n    if (charCode === undefined || charCode < -1) {\n      return undefined;\n    }\n    return osc.writePrimitive(charCode, dv, \"setUint32\", 4, offset);\n  };\n\n  /**\n   * Reads an OSC blob (\"b\") (i.e. a Uint8Array).\n   *\n   * @param {DataView} dv a DataView instance to read from\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Uint8Array} the data that was read\n   */\n  osc.readBlob = function (dv, offsetState) {\n    var len = osc.readInt32(dv, offsetState),\n      paddedLen = len + 3 & ~0x03,\n      blob = new Uint8Array(dv.buffer, offsetState.idx, len);\n    offsetState.idx += paddedLen;\n    return blob;\n  };\n\n  /**\n   * Writes a raw collection of bytes to a new ArrayBuffer.\n   *\n   * @param {Array-like} data a collection of octets\n   * @return {ArrayBuffer} a buffer containing the OSC-formatted blob\n   */\n  osc.writeBlob = function (data) {\n    data = osc.byteArray(data);\n    var len = data.byteLength,\n      paddedLen = len + 3 & ~0x03,\n      offset = 4,\n      // Extra 4 bytes is for the size.\n      blobLen = paddedLen + offset,\n      arr = new Uint8Array(blobLen),\n      dv = new DataView(arr.buffer);\n\n    // Write the size.\n    osc.writeInt32(len, dv);\n\n    // Since we're writing to a real ArrayBuffer,\n    // we don't need to pad the remaining bytes.\n    arr.set(data, offset);\n    return arr;\n  };\n\n  /**\n   * Reads an OSC 4-byte MIDI message.\n   *\n   * @param {DataView} dv the DataView instance to read from\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Uint8Array} an array containing (in order) the port ID, status, data1 and data1 bytes\n   */\n  osc.readMIDIBytes = function (dv, offsetState) {\n    var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);\n    offsetState.idx += 4;\n    return midi;\n  };\n\n  /**\n   * Writes an OSC 4-byte MIDI message.\n   *\n   * @param {Array-like} bytes a 4-element array consisting of the port ID, status, data1 and data1 bytes\n   * @return {Uint8Array} the written message\n   */\n  osc.writeMIDIBytes = function (bytes) {\n    bytes = osc.byteArray(bytes);\n    var arr = new Uint8Array(4);\n    arr.set(bytes);\n    return arr;\n  };\n\n  /**\n   * Reads an OSC RGBA colour value.\n   *\n   * @param {DataView} dv the DataView instance to read from\n   * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n   * @return {Object} a colour object containing r, g, b, and a properties\n   */\n  osc.readColor = function (dv, offsetState) {\n    var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),\n      alpha = bytes[3] / 255;\n    offsetState.idx += 4;\n    return {\n      r: bytes[0],\n      g: bytes[1],\n      b: bytes[2],\n      a: alpha\n    };\n  };\n\n  /**\n   * Writes an OSC RGBA colour value.\n   *\n   * @param {Object} color a colour object containing r, g, b, and a properties\n   * @return {Uint8Array} a byte array containing the written color\n   */\n  osc.writeColor = function (color) {\n    var alpha = Math.round(color.a * 255),\n      arr = new Uint8Array([color.r, color.g, color.b, alpha]);\n    return arr;\n  };\n\n  /**\n   * Reads an OSC true (\"T\") value by directly returning the JavaScript Boolean \"true\".\n   */\n  osc.readTrue = function () {\n    return true;\n  };\n\n  /**\n   * Reads an OSC false (\"F\") value by directly returning the JavaScript Boolean \"false\".\n   */\n  osc.readFalse = function () {\n    return false;\n  };\n\n  /**\n   * Reads an OSC nil (\"N\") value by directly returning the JavaScript \"null\" value.\n   */\n  osc.readNull = function () {\n    return null;\n  };\n\n  /**\n   * Reads an OSC impulse/bang/infinitum (\"I\") value by directly returning 1.0.\n   */\n  osc.readImpulse = function () {\n    return 1.0;\n  };\n\n  /**\n   * Reads an OSC time tag (\"t\").\n   *\n   * @param {DataView} dv the DataView instance to read from\n   * @param {Object} offsetState an offset state object containing the current index into dv\n   * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time\n   */\n  osc.readTimeTag = function (dv, offsetState) {\n    var secs1900 = osc.readPrimitive(dv, \"getUint32\", 4, offsetState),\n      frac = osc.readPrimitive(dv, \"getUint32\", 4, offsetState),\n      native = secs1900 === 0 && frac === 1 ? Date.now() : osc.ntpToJSTime(secs1900, frac);\n    return {\n      raw: [secs1900, frac],\n      native: native\n    };\n  };\n\n  /**\n   * Writes an OSC time tag (\"t\").\n   *\n   * Takes, as its argument, a time tag object containing either a \"raw\" or \"native property.\"\n   * The raw timestamp must conform to the NTP standard representation, consisting of two unsigned int32\n   * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.\n   * \"Native\" JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.\n   *\n   * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair\n   * @return {Uint8Array} raw bytes for the written time tag\n   */\n  osc.writeTimeTag = function (timeTag) {\n    var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),\n      arr = new Uint8Array(8),\n      // Two Unit32s.\n      dv = new DataView(arr.buffer);\n    osc.writeInt32(raw[0], dv, 0);\n    osc.writeInt32(raw[1], dv, 4);\n    return arr;\n  };\n\n  /**\n   * Produces a time tag containing a raw NTP timestamp\n   * relative to now by the specified number of seconds.\n   *\n   * @param {Number} secs the number of seconds relative to now (i.e. + for the future, - for the past)\n   * @param {Number} now the number of milliseconds since epoch to use as the current time. Defaults to Date.now()\n   * @return {Object} the time tag\n   */\n  osc.timeTag = function (secs, now) {\n    secs = secs || 0;\n    now = now || Date.now();\n    var nowSecs = now / 1000,\n      nowWhole = Math.floor(nowSecs),\n      nowFracs = nowSecs - nowWhole,\n      secsWhole = Math.floor(secs),\n      secsFracs = secs - secsWhole,\n      fracs = nowFracs + secsFracs;\n    if (fracs > 1) {\n      var fracsWhole = Math.floor(fracs),\n        fracsFracs = fracs - fracsWhole;\n      secsWhole += fracsWhole;\n      fracs = fracsFracs;\n    }\n    var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,\n      ntpFracs = Math.round(osc.TWO_32 * fracs);\n    return {\n      raw: [ntpSecs, ntpFracs]\n    };\n  };\n\n  /**\n   * Converts OSC's standard time tag representation (which is the NTP format)\n   * into the JavaScript/UNIX format in milliseconds.\n   *\n   * @param {Number} secs1900 the number of seconds since 1900\n   * @param {Number} frac the number of fractions of a second (between 0 and 2^32)\n   * @return {Number} a JavaScript-compatible timestamp in milliseconds\n   */\n  osc.ntpToJSTime = function (secs1900, frac) {\n    var secs1970 = secs1900 - osc.SECS_70YRS,\n      decimals = frac / osc.TWO_32,\n      msTime = (secs1970 + decimals) * 1000;\n    return msTime;\n  };\n  osc.jsToNTPTime = function (jsTime) {\n    var secs = jsTime / 1000,\n      secsWhole = Math.floor(secs),\n      secsFrac = secs - secsWhole,\n      ntpSecs = secsWhole + osc.SECS_70YRS,\n      ntpFracs = Math.round(osc.TWO_32 * secsFrac);\n    return [ntpSecs, ntpFracs];\n  };\n\n  /**\n   * Reads the argument portion of an OSC message.\n   *\n   * @param {DataView} dv a DataView instance to read from\n   * @param {Object} offsetState the offsetState object that stores the current offset into dv\n   * @param {Object} [options] read options\n   * @return {Array} an array of the OSC arguments that were read\n   */\n  osc.readArguments = function (dv, options, offsetState) {\n    var typeTagString = osc.readString(dv, offsetState);\n    if (typeTagString.indexOf(\",\") !== 0) {\n      // Despite what the OSC 1.0 spec says,\n      // it just doesn't make sense to handle messages without type tags.\n      // scsynth appears to read such messages as if they have a single\n      // Uint8 argument. sclang throws an error if the type tag is omitted.\n      throw new Error(\"A malformed type tag string was found while reading \" + \"the arguments of an OSC message. String was: \" + typeTagString, \" at offset: \" + offsetState.idx);\n    }\n    var argTypes = typeTagString.substring(1).split(\"\"),\n      args = [];\n    osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);\n    return args;\n  };\n\n  // Unsupported, non-API function.\n  osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {\n    var typeSpec = osc.argumentTypes[argType];\n    if (!typeSpec) {\n      throw new Error(\"'\" + argType + \"' is not a valid OSC type tag. Type tag string was: \" + typeTagString);\n    }\n    var argReader = typeSpec.reader,\n      arg = osc[argReader](dv, offsetState);\n    if (options.metadata) {\n      arg = {\n        type: argType,\n        value: arg\n      };\n    }\n    return arg;\n  };\n\n  // Unsupported, non-API function.\n  osc.readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {\n    var i = 0;\n    while (i < argTypes.length) {\n      var argType = argTypes[i],\n        arg;\n      if (argType === \"[\") {\n        var fromArrayOpen = argTypes.slice(i + 1),\n          endArrayIdx = fromArrayOpen.indexOf(\"]\");\n        if (endArrayIdx < 0) {\n          throw new Error(\"Invalid argument type tag: an open array type tag ('[') was found \" + \"without a matching close array tag ('[]'). Type tag was: \" + typeTagString);\n        }\n        var typesInArray = fromArrayOpen.slice(0, endArrayIdx);\n        arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);\n        i += endArrayIdx + 2;\n      } else {\n        arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);\n        i++;\n      }\n      arr.push(arg);\n    }\n    return arr;\n  };\n\n  /**\n   * Writes the specified arguments.\n   *\n   * @param {Array} args an array of arguments\n   * @param {Object} options options for writing\n   * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values\n   */\n  osc.writeArguments = function (args, options) {\n    var argCollection = osc.collectArguments(args, options);\n    return osc.joinParts(argCollection);\n  };\n\n  // Unsupported, non-API function.\n  osc.joinParts = function (dataCollection) {\n    var buf = new Uint8Array(dataCollection.byteLength),\n      parts = dataCollection.parts,\n      offset = 0;\n    for (var i = 0; i < parts.length; i++) {\n      var part = parts[i];\n      osc.copyByteArray(part, buf, offset);\n      offset += part.length;\n    }\n    return buf;\n  };\n\n  // Unsupported, non-API function.\n  osc.addDataPart = function (dataPart, dataCollection) {\n    dataCollection.parts.push(dataPart);\n    dataCollection.byteLength += dataPart.length;\n  };\n  osc.writeArrayArguments = function (args, dataCollection) {\n    var typeTag = \"[\";\n    for (var i = 0; i < args.length; i++) {\n      var arg = args[i];\n      typeTag += osc.writeArgument(arg, dataCollection);\n    }\n    typeTag += \"]\";\n    return typeTag;\n  };\n  osc.writeArgument = function (arg, dataCollection) {\n    if (osc.isArray(arg)) {\n      return osc.writeArrayArguments(arg, dataCollection);\n    }\n    var type = arg.type,\n      writer = osc.argumentTypes[type].writer;\n    if (writer) {\n      var data = osc[writer](arg.value);\n      osc.addDataPart(data, dataCollection);\n    }\n    return arg.type;\n  };\n\n  // Unsupported, non-API function.\n  osc.collectArguments = function (args, options, dataCollection) {\n    if (!osc.isArray(args)) {\n      args = typeof args === \"undefined\" ? [] : [args];\n    }\n    dataCollection = dataCollection || {\n      byteLength: 0,\n      parts: []\n    };\n    if (!options.metadata) {\n      args = osc.annotateArguments(args);\n    }\n    var typeTagString = \",\",\n      currPartIdx = dataCollection.parts.length;\n    for (var i = 0; i < args.length; i++) {\n      var arg = args[i];\n      typeTagString += osc.writeArgument(arg, dataCollection);\n    }\n    var typeData = osc.writeString(typeTagString);\n    dataCollection.byteLength += typeData.byteLength;\n    dataCollection.parts.splice(currPartIdx, 0, typeData);\n    return dataCollection;\n  };\n\n  /**\n   * Reads an OSC message.\n   *\n   * @param {Array-like} data an array of bytes to read from\n   * @param {Object} [options] read options\n   * @param {Object} [offsetState] an offsetState object that stores the current offset into dv\n   * @return {Object} the OSC message, formatted as a JavaScript object containing \"address\" and \"args\" properties\n   */\n  osc.readMessage = function (data, options, offsetState) {\n    options = options || osc.defaults;\n    var dv = osc.dataView(data, data.byteOffset, data.byteLength);\n    offsetState = offsetState || {\n      idx: 0\n    };\n    var address = osc.readString(dv, offsetState);\n    return osc.readMessageContents(address, dv, options, offsetState);\n  };\n\n  // Unsupported, non-API function.\n  osc.readMessageContents = function (address, dv, options, offsetState) {\n    if (address.indexOf(\"/\") !== 0) {\n      throw new Error(\"A malformed OSC address was found while reading \" + \"an OSC message. String was: \" + address);\n    }\n    var args = osc.readArguments(dv, options, offsetState);\n    return {\n      address: address,\n      args: args.length === 1 && options.unpackSingleArgs ? args[0] : args\n    };\n  };\n\n  // Unsupported, non-API function.\n  osc.collectMessageParts = function (msg, options, dataCollection) {\n    dataCollection = dataCollection || {\n      byteLength: 0,\n      parts: []\n    };\n    osc.addDataPart(osc.writeString(msg.address), dataCollection);\n    return osc.collectArguments(msg.args, options, dataCollection);\n  };\n\n  /**\n   * Writes an OSC message.\n   *\n   * @param {Object} msg a message object containing \"address\" and \"args\" properties\n   * @param {Object} [options] write options\n   * @return {Uint8Array} an array of bytes containing the OSC message\n   */\n  osc.writeMessage = function (msg, options) {\n    options = options || osc.defaults;\n    if (!osc.isValidMessage(msg)) {\n      throw new Error(\"An OSC message must contain a valid address. Message was: \" + JSON.stringify(msg, null, 2));\n    }\n    var msgCollection = osc.collectMessageParts(msg, options);\n    return osc.joinParts(msgCollection);\n  };\n  osc.isValidMessage = function (msg) {\n    return msg.address && msg.address.indexOf(\"/\") === 0;\n  };\n\n  /**\n   * Reads an OSC bundle.\n   *\n   * @param {DataView} dv the DataView instance to read from\n   * @param {Object} [options] read optoins\n   * @param {Object} [offsetState] an offsetState object that stores the current offset into dv\n   * @return {Object} the bundle or message object that was read\n   */\n  osc.readBundle = function (dv, options, offsetState) {\n    return osc.readPacket(dv, options, offsetState);\n  };\n\n  // Unsupported, non-API function.\n  osc.collectBundlePackets = function (bundle, options, dataCollection) {\n    dataCollection = dataCollection || {\n      byteLength: 0,\n      parts: []\n    };\n    osc.addDataPart(osc.writeString(\"#bundle\"), dataCollection);\n    osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);\n    for (var i = 0; i < bundle.packets.length; i++) {\n      var packet = bundle.packets[i],\n        collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,\n        packetCollection = collector(packet, options);\n      dataCollection.byteLength += packetCollection.byteLength;\n      osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);\n      dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);\n    }\n    return dataCollection;\n  };\n\n  /**\n   * Writes an OSC bundle.\n   *\n   * @param {Object} a bundle object containing \"timeTag\" and \"packets\" properties\n   * @param {object} [options] write options\n   * @return {Uint8Array} an array of bytes containing the message\n   */\n  osc.writeBundle = function (bundle, options) {\n    if (!osc.isValidBundle(bundle)) {\n      throw new Error(\"An OSC bundle must contain 'timeTag' and 'packets' properties. \" + \"Bundle was: \" + JSON.stringify(bundle, null, 2));\n    }\n    options = options || osc.defaults;\n    var bundleCollection = osc.collectBundlePackets(bundle, options);\n    return osc.joinParts(bundleCollection);\n  };\n  osc.isValidBundle = function (bundle) {\n    return bundle.timeTag !== undefined && bundle.packets !== undefined;\n  };\n\n  // Unsupported, non-API function.\n  osc.readBundleContents = function (dv, options, offsetState, len) {\n    var timeTag = osc.readTimeTag(dv, offsetState),\n      packets = [];\n    while (offsetState.idx < len) {\n      var packetSize = osc.readInt32(dv, offsetState),\n        packetLen = offsetState.idx + packetSize,\n        packet = osc.readPacket(dv, options, offsetState, packetLen);\n      packets.push(packet);\n    }\n    return {\n      timeTag: timeTag,\n      packets: packets\n    };\n  };\n\n  /**\n   * Reads an OSC packet, which may consist of either a bundle or a message.\n   *\n   * @param {Array-like} data an array of bytes to read from\n   * @param {Object} [options] read options\n   * @return {Object} a bundle or message object\n   */\n  osc.readPacket = function (data, options, offsetState, len) {\n    var dv = osc.dataView(data, data.byteOffset, data.byteLength);\n    len = len === undefined ? dv.byteLength : len;\n    offsetState = offsetState || {\n      idx: 0\n    };\n    var header = osc.readString(dv, offsetState),\n      firstChar = header[0];\n    if (firstChar === \"#\") {\n      return osc.readBundleContents(dv, options, offsetState, len);\n    } else if (firstChar === \"/\") {\n      return osc.readMessageContents(header, dv, options, offsetState);\n    }\n    throw new Error(\"The header of an OSC packet didn't contain an OSC address or a #bundle string.\" + \" Header was: \" + header);\n  };\n\n  /**\n   * Writes an OSC packet, which may consist of either of a bundle or a message.\n   *\n   * @param {Object} a bundle or message object\n   * @param {Object} [options] write options\n   * @return {Uint8Array} an array of bytes containing the message\n   */\n  osc.writePacket = function (packet, options) {\n    if (osc.isValidMessage(packet)) {\n      return osc.writeMessage(packet, options);\n    } else if (osc.isValidBundle(packet)) {\n      return osc.writeBundle(packet, options);\n    } else {\n      throw new Error(\"The specified packet was not recognized as a valid OSC message or bundle.\" + \" Packet was: \" + JSON.stringify(packet, null, 2));\n    }\n  };\n\n  // Unsupported, non-API.\n  osc.argumentTypes = {\n    i: {\n      reader: \"readInt32\",\n      writer: \"writeInt32\"\n    },\n    h: {\n      reader: \"readInt64\",\n      writer: \"writeInt64\"\n    },\n    f: {\n      reader: \"readFloat32\",\n      writer: \"writeFloat32\"\n    },\n    s: {\n      reader: \"readString\",\n      writer: \"writeString\"\n    },\n    S: {\n      reader: \"readString\",\n      writer: \"writeString\"\n    },\n    b: {\n      reader: \"readBlob\",\n      writer: \"writeBlob\"\n    },\n    t: {\n      reader: \"readTimeTag\",\n      writer: \"writeTimeTag\"\n    },\n    T: {\n      reader: \"readTrue\"\n    },\n    F: {\n      reader: \"readFalse\"\n    },\n    N: {\n      reader: \"readNull\"\n    },\n    I: {\n      reader: \"readImpulse\"\n    },\n    d: {\n      reader: \"readFloat64\",\n      writer: \"writeFloat64\"\n    },\n    c: {\n      reader: \"readChar32\",\n      writer: \"writeChar32\"\n    },\n    r: {\n      reader: \"readColor\",\n      writer: \"writeColor\"\n    },\n    m: {\n      reader: \"readMIDIBytes\",\n      writer: \"writeMIDIBytes\"\n    }\n    // [] are special cased within read/writeArguments()\n  };\n\n  // Unsupported, non-API function.\n  osc.inferTypeForArgument = function (arg) {\n    var type = typeof arg;\n\n    // TODO: This is freaking hideous.\n    switch (type) {\n      case \"boolean\":\n        return arg ? \"T\" : \"F\";\n      case \"string\":\n        return \"s\";\n      case \"number\":\n        return \"f\";\n      case \"undefined\":\n        return \"N\";\n      case \"object\":\n        if (arg === null) {\n          return \"N\";\n        } else if (arg instanceof Uint8Array || arg instanceof ArrayBuffer) {\n          return \"b\";\n        } else if (typeof arg.high === \"number\" && typeof arg.low === \"number\") {\n          return \"h\";\n        }\n        break;\n    }\n    throw new Error(\"Can't infer OSC argument type for value: \" + JSON.stringify(arg, null, 2));\n  };\n\n  // Unsupported, non-API function.\n  osc.annotateArguments = function (args) {\n    var annotated = [];\n    for (var i = 0; i < args.length; i++) {\n      var arg = args[i],\n        msgArg;\n      if (typeof arg === \"object\" && arg.type && arg.value !== undefined) {\n        // We've got an explicitly typed argument.\n        msgArg = arg;\n      } else if (osc.isArray(arg)) {\n        // We've got an array of arguments,\n        // so they each need to be inferred and expanded.\n        msgArg = osc.annotateArguments(arg);\n      } else {\n        var oscType = osc.inferTypeForArgument(arg);\n        msgArg = {\n          type: oscType,\n          value: arg\n        };\n      }\n      annotated.push(msgArg);\n    }\n    return annotated;\n  };\n  if (osc.isCommonJS) {\n    module.exports = osc;\n  }\n})();","map":{"version":3,"names":["osc","SECS_70YRS","TWO_32","defaults","metadata","unpackSingleArgs","isCommonJS","module","exports","isNode","window","isElectron","process","versions","electron","isBufferEnv","isArray","obj","Object","prototype","toString","call","isTypedArrayView","buffer","ArrayBuffer","isBuffer","Buffer","Long","require","undefined","TextDecoder","util","TextEncoder","dataView","offset","length","DataView","Uint8Array","byteArray","buf","Error","JSON","stringify","nativeBuffer","from","copyByteArray","source","target","set","start","len","Math","min","i","j","readString","dv","offsetState","charCodes","idx","byteLength","charCode","getUint8","push","decoder","withBuffer","withTextDecoder","raw","str","sliceSize","String","fromCharCode","apply","slice","data","Int8Array","decode","writeString","encoder","withTextEncoder","terminated","encodedStr","paddedLen","arr","charCodeAt","encode","readPrimitive","readerName","numBytes","val","writePrimitive","writerName","readInt32","writeInt32","readInt64","high","low","unsigned","writeInt64","readFloat32","writeFloat32","readFloat64","writeFloat64","readChar32","writeChar32","readBlob","blob","writeBlob","blobLen","readMIDIBytes","midi","writeMIDIBytes","bytes","readColor","alpha","r","g","b","a","writeColor","color","round","readTrue","readFalse","readNull","readImpulse","readTimeTag","secs1900","frac","native","Date","now","ntpToJSTime","writeTimeTag","timeTag","jsToNTPTime","secs","nowSecs","nowWhole","floor","nowFracs","secsWhole","secsFracs","fracs","fracsWhole","fracsFracs","ntpSecs","ntpFracs","secs1970","decimals","msTime","jsTime","secsFrac","readArguments","options","typeTagString","indexOf","argTypes","substring","split","args","readArgumentsIntoArray","readArgument","argType","typeSpec","argumentTypes","argReader","reader","arg","type","value","fromArrayOpen","endArrayIdx","typesInArray","writeArguments","argCollection","collectArguments","joinParts","dataCollection","parts","part","addDataPart","dataPart","writeArrayArguments","typeTag","writeArgument","writer","annotateArguments","currPartIdx","typeData","splice","readMessage","byteOffset","address","readMessageContents","collectMessageParts","msg","writeMessage","isValidMessage","msgCollection","readBundle","readPacket","collectBundlePackets","bundle","packets","packet","collector","packetCollection","concat","writeBundle","isValidBundle","bundleCollection","readBundleContents","packetSize","packetLen","header","firstChar","writePacket","h","f","s","S","t","T","F","N","I","d","c","m","inferTypeForArgument","annotated","msgArg","oscType"],"sources":["C:/Users/tmart/Desktop/Dissertacao/TourOfHeroes/tour-of-heroes-osc.js/tour-of-heroes/node_modules/osc/src/osc.js"],"sourcesContent":["/*\n * osc.js: An Open Sound Control library for JavaScript that works in both the browser and Node.js\n *\n * Copyright 2014-2016, Colin Clark\n * Licensed under the MIT and GPL 3 licenses.\n */\n\n/* global require, module, process, Buffer, Long, util */\n\nvar osc = osc || {};\n\n(function () {\n\n    \"use strict\";\n\n    osc.SECS_70YRS = 2208988800;\n    osc.TWO_32 = 4294967296;\n\n    osc.defaults = {\n        metadata: false,\n        unpackSingleArgs: true\n    };\n\n    // Unsupported, non-API property.\n    osc.isCommonJS = typeof module !== \"undefined\" && module.exports ? true : false;\n\n    // Unsupported, non-API property.\n    osc.isNode = osc.isCommonJS && typeof window === \"undefined\";\n\n    // Unsupported, non-API property.\n    osc.isElectron = typeof process !== \"undefined\" &&\n        process.versions && process.versions.electron ? true : false;\n\n    // Unsupported, non-API property.\n    osc.isBufferEnv = osc.isNode || osc.isElectron;\n\n    // Unsupported, non-API function.\n    osc.isArray = function (obj) {\n        return obj && Object.prototype.toString.call(obj) === \"[object Array]\";\n    };\n\n    // Unsupported, non-API function.\n    osc.isTypedArrayView = function (obj) {\n        return obj.buffer && obj.buffer instanceof ArrayBuffer;\n    };\n\n    // Unsupported, non-API function.\n    osc.isBuffer = function (obj) {\n        return osc.isBufferEnv && obj instanceof Buffer;\n    };\n\n    // Unsupported, non-API member.\n    osc.Long = typeof Long !== \"undefined\" ? Long :\n        osc.isNode ? require(\"long\") : undefined;\n\n    // Unsupported, non-API member. Can be removed when supported versions\n    // of Node.js expose TextDecoder as a global, as in the browser.\n    osc.TextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\") :\n        typeof util !== \"undefined\" && typeof (util.TextDecoder !== \"undefined\") ? new util.TextDecoder(\"utf-8\") : undefined;\n\n    osc.TextEncoder = typeof TextEncoder !== \"undefined\" ? new TextEncoder(\"utf-8\") :\n        typeof util !== \"undefined\" && typeof (util.TextEncoder !== \"undefined\") ? new util.TextEncoder(\"utf-8\") : undefined;\n\n    /**\n     * Wraps the specified object in a DataView.\n     *\n     * @param {Array-like} obj the object to wrap in a DataView instance\n     * @return {DataView} the DataView object\n     */\n    // Unsupported, non-API function.\n    osc.dataView = function (obj, offset, length) {\n        if (obj.buffer) {\n            return new DataView(obj.buffer, offset, length);\n        }\n\n        if (obj instanceof ArrayBuffer) {\n            return new DataView(obj, offset, length);\n        }\n\n        return new DataView(new Uint8Array(obj), offset, length);\n    };\n\n    /**\n     * Takes an ArrayBuffer, TypedArray, DataView, Buffer, or array-like object\n     * and returns a Uint8Array view of it.\n     *\n     * Throws an error if the object isn't suitably array-like.\n     *\n     * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object\n     * @returns {Uint8Array} a typed array of octets\n     */\n    // Unsupported, non-API function.\n    osc.byteArray = function (obj) {\n        if (obj instanceof Uint8Array) {\n            return obj;\n        }\n\n        var buf = obj.buffer ? obj.buffer : obj;\n\n        if (!(buf instanceof ArrayBuffer) && (typeof buf.length === \"undefined\" || typeof buf === \"string\")) {\n            throw new Error(\"Can't wrap a non-array-like object as Uint8Array. Object was: \" +\n                JSON.stringify(obj, null, 2));\n        }\n\n\n        // TODO gh-39: This is a potentially unsafe algorithm;\n        // if we're getting anything other than a TypedArrayView (such as a DataView),\n        // we really need to determine the range of the view it is viewing.\n        return new Uint8Array(buf);\n    };\n\n    /**\n     * Takes an ArrayBuffer, TypedArray, DataView, or array-like object\n     * and returns a native buffer object\n     * (i.e. in Node.js, a Buffer object and in the browser, a Uint8Array).\n     *\n     * Throws an error if the object isn't suitably array-like.\n     *\n     * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object\n     * @returns {Buffer|Uint8Array} a buffer object\n     */\n    // Unsupported, non-API function.\n    osc.nativeBuffer = function (obj) {\n        if (osc.isBufferEnv) {\n            return osc.isBuffer(obj) ? obj :\n                Buffer.from(obj.buffer ? obj : new Uint8Array(obj));\n        }\n\n        return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);\n    };\n\n    // Unsupported, non-API function\n    osc.copyByteArray = function (source, target, offset) {\n        if (osc.isTypedArrayView(source) && osc.isTypedArrayView(target)) {\n            target.set(source, offset);\n        } else {\n            var start = offset === undefined ? 0 : offset,\n                len = Math.min(target.length - offset, source.length);\n\n            for (var i = 0, j = start; i < len; i++, j++) {\n                target[j] = source[i];\n            }\n        }\n\n        return target;\n    };\n\n    /**\n     * Reads an OSC-formatted string.\n     *\n     * @param {DataView} dv a DataView containing the raw bytes of the OSC string\n     * @param {Object} offsetState an offsetState object used to store the current offset index\n     * @return {String} the JavaScript String that was read\n     */\n    osc.readString = function (dv, offsetState) {\n        var charCodes = [],\n            idx = offsetState.idx;\n\n        for (; idx < dv.byteLength; idx++) {\n            var charCode = dv.getUint8(idx);\n            if (charCode !== 0) {\n                charCodes.push(charCode);\n            } else {\n                idx++;\n                break;\n            }\n        }\n\n        // Round to the nearest 4-byte block.\n        idx = (idx + 3) & ~0x03;\n        offsetState.idx = idx;\n\n        var decoder = osc.isBufferEnv ? osc.readString.withBuffer :\n            osc.TextDecoder ? osc.readString.withTextDecoder : osc.readString.raw;\n\n        return decoder(charCodes);\n    };\n\n    osc.readString.raw = function (charCodes) {\n        // If no Buffer or TextDecoder, resort to fromCharCode\n        // This does not properly decode multi-byte Unicode characters.\n        var str = \"\";\n        var sliceSize = 10000;\n\n        // Processing the array in chunks so as not to exceed argument\n        // limit, see https://bugs.webkit.org/show_bug.cgi?id=80797\n        for (var i = 0; i < charCodes.length; i += sliceSize) {\n            str += String.fromCharCode.apply(null, charCodes.slice(i, i + sliceSize));\n        }\n\n        return str;\n    };\n\n    osc.readString.withTextDecoder = function (charCodes) {\n        var data = new Int8Array(charCodes);\n        return osc.TextDecoder.decode(data);\n    };\n\n    osc.readString.withBuffer = function (charCodes) {\n        return Buffer.from(charCodes).toString(\"utf-8\");\n    };\n\n    /**\n     * Writes a JavaScript string as an OSC-formatted string.\n     *\n     * @param {String} str the string to write\n     * @return {Uint8Array} a buffer containing the OSC-formatted string\n     */\n    osc.writeString = function (str) {\n\n        var encoder = osc.isBufferEnv ? osc.writeString.withBuffer :\n            osc.TextEncoder ? osc.writeString.withTextEncoder : null,\n            terminated = str + \"\\u0000\",\n            encodedStr;\n\n        if (encoder) {\n            encodedStr = encoder(terminated);\n        }\n\n        var len = encoder ? encodedStr.length : terminated.length,\n            paddedLen = (len + 3) & ~0x03,\n            arr = new Uint8Array(paddedLen);\n\n        for (var i = 0; i < len - 1; i++) {\n            var charCode = encoder ? encodedStr[i] : terminated.charCodeAt(i);\n            arr[i] = charCode;\n        }\n\n        return arr;\n    };\n\n    osc.writeString.withTextEncoder = function (str) {\n        return osc.TextEncoder.encode(str);\n    };\n\n    osc.writeString.withBuffer = function (str) {\n        return Buffer.from(str);\n    };\n\n    // Unsupported, non-API function.\n    osc.readPrimitive = function (dv, readerName, numBytes, offsetState) {\n        var val = dv[readerName](offsetState.idx, false);\n        offsetState.idx += numBytes;\n\n        return val;\n    };\n\n    // Unsupported, non-API function.\n    osc.writePrimitive = function (val, dv, writerName, numBytes, offset) {\n        offset = offset === undefined ? 0 : offset;\n\n        var arr;\n        if (!dv) {\n            arr = new Uint8Array(numBytes);\n            dv = new DataView(arr.buffer);\n        } else {\n            arr = new Uint8Array(dv.buffer);\n        }\n\n        dv[writerName](offset, val, false);\n\n        return arr;\n    };\n\n    /**\n     * Reads an OSC int32 (\"i\") value.\n     *\n     * @param {DataView} dv a DataView containing the raw bytes\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Number} the number that was read\n     */\n    osc.readInt32 = function (dv, offsetState) {\n        return osc.readPrimitive(dv, \"getInt32\", 4, offsetState);\n    };\n\n    /**\n     * Writes an OSC int32 (\"i\") value.\n     *\n     * @param {Number} val the number to write\n     * @param {DataView} [dv] a DataView instance to write the number into\n     * @param {Number} [offset] an offset into dv\n     */\n    osc.writeInt32 = function (val, dv, offset) {\n        return osc.writePrimitive(val, dv, \"setInt32\", 4, offset);\n    };\n\n    /**\n     * Reads an OSC int64 (\"h\") value.\n     *\n     * @param {DataView} dv a DataView containing the raw bytes\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Number} the number that was read\n     */\n    osc.readInt64 = function (dv, offsetState) {\n        var high = osc.readPrimitive(dv, \"getInt32\", 4, offsetState),\n            low = osc.readPrimitive(dv, \"getInt32\", 4, offsetState);\n\n        if (osc.Long) {\n            return new osc.Long(low, high);\n        } else {\n            return {\n                high: high,\n                low: low,\n                unsigned: false\n            };\n        }\n    };\n\n    /**\n     * Writes an OSC int64 (\"h\") value.\n     *\n     * @param {Number} val the number to write\n     * @param {DataView} [dv] a DataView instance to write the number into\n     * @param {Number} [offset] an offset into dv\n     */\n    osc.writeInt64 = function (val, dv, offset) {\n        var arr = new Uint8Array(8);\n        arr.set(osc.writePrimitive(val.high, dv, \"setInt32\", 4, offset), 0);\n        arr.set(osc.writePrimitive(val.low,  dv, \"setInt32\", 4, offset + 4), 4);\n        return arr;\n    };\n\n    /**\n     * Reads an OSC float32 (\"f\") value.\n     *\n     * @param {DataView} dv a DataView containing the raw bytes\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Number} the number that was read\n     */\n    osc.readFloat32 = function (dv, offsetState) {\n        return osc.readPrimitive(dv, \"getFloat32\", 4, offsetState);\n    };\n\n    /**\n     * Writes an OSC float32 (\"f\") value.\n     *\n     * @param {Number} val the number to write\n     * @param {DataView} [dv] a DataView instance to write the number into\n     * @param {Number} [offset] an offset into dv\n     */\n    osc.writeFloat32 = function (val, dv, offset) {\n        return osc.writePrimitive(val, dv, \"setFloat32\", 4, offset);\n    };\n\n    /**\n     * Reads an OSC float64 (\"d\") value.\n     *\n     * @param {DataView} dv a DataView containing the raw bytes\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Number} the number that was read\n     */\n    osc.readFloat64 = function (dv, offsetState) {\n        return osc.readPrimitive(dv, \"getFloat64\", 8, offsetState);\n    };\n\n    /**\n     * Writes an OSC float64 (\"d\") value.\n     *\n     * @param {Number} val the number to write\n     * @param {DataView} [dv] a DataView instance to write the number into\n     * @param {Number} [offset] an offset into dv\n     */\n    osc.writeFloat64 = function (val, dv, offset) {\n        return osc.writePrimitive(val, dv, \"setFloat64\", 8, offset);\n    };\n\n    /**\n     * Reads an OSC 32-bit ASCII character (\"c\") value.\n     *\n     * @param {DataView} dv a DataView containing the raw bytes\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {String} a string containing the read character\n     */\n    osc.readChar32 = function (dv, offsetState) {\n        var charCode = osc.readPrimitive(dv, \"getUint32\", 4, offsetState);\n        return String.fromCharCode(charCode);\n    };\n\n    /**\n     * Writes an OSC 32-bit ASCII character (\"c\") value.\n     *\n     * @param {String} str the string from which the first character will be written\n     * @param {DataView} [dv] a DataView instance to write the character into\n     * @param {Number} [offset] an offset into dv\n     * @return {String} a string containing the read character\n     */\n    osc.writeChar32 = function (str, dv, offset) {\n        var charCode = str.charCodeAt(0);\n        if (charCode === undefined || charCode < -1) {\n            return undefined;\n        }\n\n        return osc.writePrimitive(charCode, dv, \"setUint32\", 4, offset);\n    };\n\n    /**\n     * Reads an OSC blob (\"b\") (i.e. a Uint8Array).\n     *\n     * @param {DataView} dv a DataView instance to read from\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Uint8Array} the data that was read\n     */\n    osc.readBlob = function (dv, offsetState) {\n        var len = osc.readInt32(dv, offsetState),\n            paddedLen = (len + 3) & ~0x03,\n            blob = new Uint8Array(dv.buffer, offsetState.idx, len);\n\n        offsetState.idx += paddedLen;\n\n        return blob;\n    };\n\n    /**\n     * Writes a raw collection of bytes to a new ArrayBuffer.\n     *\n     * @param {Array-like} data a collection of octets\n     * @return {ArrayBuffer} a buffer containing the OSC-formatted blob\n     */\n    osc.writeBlob = function (data) {\n        data = osc.byteArray(data);\n\n        var len = data.byteLength,\n            paddedLen = (len + 3) & ~0x03,\n            offset = 4, // Extra 4 bytes is for the size.\n            blobLen = paddedLen + offset,\n            arr = new Uint8Array(blobLen),\n            dv = new DataView(arr.buffer);\n\n        // Write the size.\n        osc.writeInt32(len, dv);\n\n        // Since we're writing to a real ArrayBuffer,\n        // we don't need to pad the remaining bytes.\n        arr.set(data, offset);\n\n        return arr;\n    };\n\n    /**\n     * Reads an OSC 4-byte MIDI message.\n     *\n     * @param {DataView} dv the DataView instance to read from\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Uint8Array} an array containing (in order) the port ID, status, data1 and data1 bytes\n     */\n    osc.readMIDIBytes = function (dv, offsetState) {\n        var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);\n        offsetState.idx += 4;\n\n        return midi;\n    };\n\n    /**\n     * Writes an OSC 4-byte MIDI message.\n     *\n     * @param {Array-like} bytes a 4-element array consisting of the port ID, status, data1 and data1 bytes\n     * @return {Uint8Array} the written message\n     */\n    osc.writeMIDIBytes = function (bytes) {\n        bytes = osc.byteArray(bytes);\n\n        var arr = new Uint8Array(4);\n        arr.set(bytes);\n\n        return arr;\n    };\n\n    /**\n     * Reads an OSC RGBA colour value.\n     *\n     * @param {DataView} dv the DataView instance to read from\n     * @param {Object} offsetState an offsetState object used to store the current offset index into dv\n     * @return {Object} a colour object containing r, g, b, and a properties\n     */\n    osc.readColor = function (dv, offsetState) {\n        var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),\n            alpha = bytes[3] / 255;\n\n        offsetState.idx += 4;\n\n        return {\n            r: bytes[0],\n            g: bytes[1],\n            b: bytes[2],\n            a: alpha\n        };\n    };\n\n    /**\n     * Writes an OSC RGBA colour value.\n     *\n     * @param {Object} color a colour object containing r, g, b, and a properties\n     * @return {Uint8Array} a byte array containing the written color\n     */\n    osc.writeColor = function (color) {\n        var alpha = Math.round(color.a * 255),\n            arr = new Uint8Array([color.r, color.g, color.b, alpha]);\n\n        return arr;\n    };\n\n    /**\n     * Reads an OSC true (\"T\") value by directly returning the JavaScript Boolean \"true\".\n     */\n    osc.readTrue = function () {\n        return true;\n    };\n\n    /**\n     * Reads an OSC false (\"F\") value by directly returning the JavaScript Boolean \"false\".\n     */\n    osc.readFalse = function () {\n        return false;\n    };\n\n    /**\n     * Reads an OSC nil (\"N\") value by directly returning the JavaScript \"null\" value.\n     */\n    osc.readNull = function () {\n        return null;\n    };\n\n    /**\n     * Reads an OSC impulse/bang/infinitum (\"I\") value by directly returning 1.0.\n     */\n    osc.readImpulse = function () {\n        return 1.0;\n    };\n\n    /**\n     * Reads an OSC time tag (\"t\").\n     *\n     * @param {DataView} dv the DataView instance to read from\n     * @param {Object} offsetState an offset state object containing the current index into dv\n     * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time\n     */\n    osc.readTimeTag = function (dv, offsetState) {\n        var secs1900 = osc.readPrimitive(dv, \"getUint32\", 4, offsetState),\n            frac = osc.readPrimitive(dv, \"getUint32\", 4, offsetState),\n            native = (secs1900 === 0 && frac === 1) ? Date.now() : osc.ntpToJSTime(secs1900, frac);\n\n        return {\n            raw: [secs1900, frac],\n            native: native\n        };\n    };\n\n    /**\n     * Writes an OSC time tag (\"t\").\n     *\n     * Takes, as its argument, a time tag object containing either a \"raw\" or \"native property.\"\n     * The raw timestamp must conform to the NTP standard representation, consisting of two unsigned int32\n     * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.\n     * \"Native\" JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.\n     *\n     * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair\n     * @return {Uint8Array} raw bytes for the written time tag\n     */\n    osc.writeTimeTag = function (timeTag) {\n        var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),\n            arr = new Uint8Array(8), // Two Unit32s.\n            dv = new DataView(arr.buffer);\n\n        osc.writeInt32(raw[0], dv, 0);\n        osc.writeInt32(raw[1], dv, 4);\n\n        return arr;\n    };\n\n    /**\n     * Produces a time tag containing a raw NTP timestamp\n     * relative to now by the specified number of seconds.\n     *\n     * @param {Number} secs the number of seconds relative to now (i.e. + for the future, - for the past)\n     * @param {Number} now the number of milliseconds since epoch to use as the current time. Defaults to Date.now()\n     * @return {Object} the time tag\n     */\n    osc.timeTag = function (secs, now) {\n        secs = secs || 0;\n        now = now || Date.now();\n\n        var nowSecs = now / 1000,\n            nowWhole = Math.floor(nowSecs),\n            nowFracs = nowSecs - nowWhole,\n            secsWhole = Math.floor(secs),\n            secsFracs = secs - secsWhole,\n            fracs = nowFracs + secsFracs;\n\n        if (fracs > 1) {\n            var fracsWhole = Math.floor(fracs),\n                fracsFracs = fracs - fracsWhole;\n\n            secsWhole += fracsWhole;\n            fracs = fracsFracs;\n        }\n\n        var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,\n            ntpFracs = Math.round(osc.TWO_32 * fracs);\n\n        return {\n            raw: [ntpSecs, ntpFracs]\n        };\n    };\n\n    /**\n     * Converts OSC's standard time tag representation (which is the NTP format)\n     * into the JavaScript/UNIX format in milliseconds.\n     *\n     * @param {Number} secs1900 the number of seconds since 1900\n     * @param {Number} frac the number of fractions of a second (between 0 and 2^32)\n     * @return {Number} a JavaScript-compatible timestamp in milliseconds\n     */\n    osc.ntpToJSTime = function (secs1900, frac) {\n        var secs1970 = secs1900 - osc.SECS_70YRS,\n            decimals = frac / osc.TWO_32,\n            msTime = (secs1970 + decimals) * 1000;\n\n        return msTime;\n    };\n\n    osc.jsToNTPTime = function (jsTime) {\n        var secs = jsTime / 1000,\n            secsWhole = Math.floor(secs),\n            secsFrac = secs - secsWhole,\n            ntpSecs = secsWhole + osc.SECS_70YRS,\n            ntpFracs = Math.round(osc.TWO_32 * secsFrac);\n\n        return [ntpSecs, ntpFracs];\n    };\n\n    /**\n     * Reads the argument portion of an OSC message.\n     *\n     * @param {DataView} dv a DataView instance to read from\n     * @param {Object} offsetState the offsetState object that stores the current offset into dv\n     * @param {Object} [options] read options\n     * @return {Array} an array of the OSC arguments that were read\n     */\n    osc.readArguments = function (dv, options, offsetState) {\n        var typeTagString = osc.readString(dv, offsetState);\n        if (typeTagString.indexOf(\",\") !== 0) {\n            // Despite what the OSC 1.0 spec says,\n            // it just doesn't make sense to handle messages without type tags.\n            // scsynth appears to read such messages as if they have a single\n            // Uint8 argument. sclang throws an error if the type tag is omitted.\n            throw new Error(\"A malformed type tag string was found while reading \" +\n                \"the arguments of an OSC message. String was: \" +\n                typeTagString, \" at offset: \" + offsetState.idx);\n        }\n\n        var argTypes = typeTagString.substring(1).split(\"\"),\n            args = [];\n\n        osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);\n\n        return args;\n    };\n\n    // Unsupported, non-API function.\n    osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {\n        var typeSpec = osc.argumentTypes[argType];\n        if (!typeSpec) {\n            throw new Error(\"'\" + argType + \"' is not a valid OSC type tag. Type tag string was: \" + typeTagString);\n        }\n\n        var argReader = typeSpec.reader,\n            arg = osc[argReader](dv, offsetState);\n\n        if (options.metadata) {\n            arg = {\n                type: argType,\n                value: arg\n            };\n        }\n\n        return arg;\n    };\n\n    // Unsupported, non-API function.\n    osc.readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {\n        var i = 0;\n\n        while (i < argTypes.length) {\n            var argType = argTypes[i],\n                arg;\n\n            if (argType === \"[\") {\n                var fromArrayOpen = argTypes.slice(i + 1),\n                    endArrayIdx = fromArrayOpen.indexOf(\"]\");\n\n                if (endArrayIdx < 0) {\n                    throw new Error(\"Invalid argument type tag: an open array type tag ('[') was found \" +\n                        \"without a matching close array tag ('[]'). Type tag was: \" + typeTagString);\n                }\n\n                var typesInArray = fromArrayOpen.slice(0, endArrayIdx);\n                arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);\n                i += endArrayIdx + 2;\n            } else {\n                arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);\n                i++;\n            }\n\n            arr.push(arg);\n        }\n\n        return arr;\n    };\n\n    /**\n     * Writes the specified arguments.\n     *\n     * @param {Array} args an array of arguments\n     * @param {Object} options options for writing\n     * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values\n     */\n    osc.writeArguments = function (args, options) {\n        var argCollection = osc.collectArguments(args, options);\n        return osc.joinParts(argCollection);\n    };\n\n    // Unsupported, non-API function.\n    osc.joinParts = function (dataCollection) {\n        var buf = new Uint8Array(dataCollection.byteLength),\n            parts = dataCollection.parts,\n            offset = 0;\n\n        for (var i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            osc.copyByteArray(part, buf, offset);\n            offset += part.length;\n        }\n\n        return buf;\n    };\n\n    // Unsupported, non-API function.\n    osc.addDataPart = function (dataPart, dataCollection) {\n        dataCollection.parts.push(dataPart);\n        dataCollection.byteLength += dataPart.length;\n    };\n\n    osc.writeArrayArguments = function (args, dataCollection) {\n        var typeTag = \"[\";\n\n        for (var i = 0; i < args.length; i++) {\n            var arg = args[i];\n            typeTag += osc.writeArgument(arg, dataCollection);\n        }\n\n        typeTag += \"]\";\n\n        return typeTag;\n    };\n\n    osc.writeArgument = function (arg, dataCollection) {\n        if (osc.isArray(arg)) {\n            return osc.writeArrayArguments(arg, dataCollection);\n        }\n\n        var type = arg.type,\n            writer = osc.argumentTypes[type].writer;\n\n        if (writer) {\n            var data = osc[writer](arg.value);\n            osc.addDataPart(data, dataCollection);\n        }\n\n        return arg.type;\n    };\n\n    // Unsupported, non-API function.\n    osc.collectArguments = function (args, options, dataCollection) {\n        if (!osc.isArray(args)) {\n            args = typeof args === \"undefined\" ? [] : [args];\n        }\n\n        dataCollection = dataCollection || {\n            byteLength: 0,\n            parts: []\n        };\n\n        if (!options.metadata) {\n            args = osc.annotateArguments(args);\n        }\n\n        var typeTagString = \",\",\n            currPartIdx = dataCollection.parts.length;\n\n        for (var i = 0; i < args.length; i++) {\n            var arg = args[i];\n            typeTagString += osc.writeArgument(arg, dataCollection);\n        }\n\n        var typeData = osc.writeString(typeTagString);\n        dataCollection.byteLength += typeData.byteLength;\n        dataCollection.parts.splice(currPartIdx, 0, typeData);\n\n        return dataCollection;\n    };\n\n    /**\n     * Reads an OSC message.\n     *\n     * @param {Array-like} data an array of bytes to read from\n     * @param {Object} [options] read options\n     * @param {Object} [offsetState] an offsetState object that stores the current offset into dv\n     * @return {Object} the OSC message, formatted as a JavaScript object containing \"address\" and \"args\" properties\n     */\n    osc.readMessage = function (data, options, offsetState) {\n        options = options || osc.defaults;\n\n        var dv = osc.dataView(data, data.byteOffset, data.byteLength);\n        offsetState = offsetState || {\n            idx: 0\n        };\n\n        var address = osc.readString(dv, offsetState);\n        return osc.readMessageContents(address, dv, options, offsetState);\n    };\n\n    // Unsupported, non-API function.\n    osc.readMessageContents = function (address, dv, options, offsetState) {\n        if (address.indexOf(\"/\") !== 0) {\n            throw new Error(\"A malformed OSC address was found while reading \" +\n                \"an OSC message. String was: \" + address);\n        }\n\n        var args = osc.readArguments(dv, options, offsetState);\n\n        return {\n            address: address,\n            args: args.length === 1 && options.unpackSingleArgs ? args[0] : args\n        };\n    };\n\n    // Unsupported, non-API function.\n    osc.collectMessageParts = function (msg, options, dataCollection) {\n        dataCollection = dataCollection || {\n            byteLength: 0,\n            parts: []\n        };\n\n        osc.addDataPart(osc.writeString(msg.address), dataCollection);\n        return osc.collectArguments(msg.args, options, dataCollection);\n    };\n\n    /**\n     * Writes an OSC message.\n     *\n     * @param {Object} msg a message object containing \"address\" and \"args\" properties\n     * @param {Object} [options] write options\n     * @return {Uint8Array} an array of bytes containing the OSC message\n     */\n    osc.writeMessage = function (msg, options) {\n        options = options || osc.defaults;\n\n        if (!osc.isValidMessage(msg)) {\n            throw new Error(\"An OSC message must contain a valid address. Message was: \" +\n                JSON.stringify(msg, null, 2));\n        }\n\n        var msgCollection = osc.collectMessageParts(msg, options);\n        return osc.joinParts(msgCollection);\n    };\n\n    osc.isValidMessage = function (msg) {\n        return msg.address && msg.address.indexOf(\"/\") === 0;\n    };\n\n    /**\n     * Reads an OSC bundle.\n     *\n     * @param {DataView} dv the DataView instance to read from\n     * @param {Object} [options] read optoins\n     * @param {Object} [offsetState] an offsetState object that stores the current offset into dv\n     * @return {Object} the bundle or message object that was read\n     */\n    osc.readBundle = function (dv, options, offsetState) {\n        return osc.readPacket(dv, options, offsetState);\n    };\n\n    // Unsupported, non-API function.\n    osc.collectBundlePackets = function (bundle, options, dataCollection) {\n        dataCollection = dataCollection || {\n            byteLength: 0,\n            parts: []\n        };\n\n        osc.addDataPart(osc.writeString(\"#bundle\"), dataCollection);\n        osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);\n\n        for (var i = 0; i < bundle.packets.length; i++) {\n            var packet = bundle.packets[i],\n                collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,\n                packetCollection = collector(packet, options);\n\n            dataCollection.byteLength += packetCollection.byteLength;\n            osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);\n            dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);\n        }\n\n        return dataCollection;\n    };\n\n    /**\n     * Writes an OSC bundle.\n     *\n     * @param {Object} a bundle object containing \"timeTag\" and \"packets\" properties\n     * @param {object} [options] write options\n     * @return {Uint8Array} an array of bytes containing the message\n     */\n    osc.writeBundle = function (bundle, options) {\n        if (!osc.isValidBundle(bundle)) {\n            throw new Error(\"An OSC bundle must contain 'timeTag' and 'packets' properties. \" +\n                \"Bundle was: \" + JSON.stringify(bundle, null, 2));\n        }\n\n        options = options || osc.defaults;\n        var bundleCollection = osc.collectBundlePackets(bundle, options);\n\n        return osc.joinParts(bundleCollection);\n    };\n\n    osc.isValidBundle = function (bundle) {\n        return bundle.timeTag !== undefined && bundle.packets !== undefined;\n    };\n\n    // Unsupported, non-API function.\n    osc.readBundleContents = function (dv, options, offsetState, len) {\n        var timeTag = osc.readTimeTag(dv, offsetState),\n            packets = [];\n\n        while (offsetState.idx < len) {\n            var packetSize = osc.readInt32(dv, offsetState),\n                packetLen = offsetState.idx + packetSize,\n                packet = osc.readPacket(dv, options, offsetState, packetLen);\n\n            packets.push(packet);\n        }\n\n        return {\n            timeTag: timeTag,\n            packets: packets\n        };\n    };\n\n    /**\n     * Reads an OSC packet, which may consist of either a bundle or a message.\n     *\n     * @param {Array-like} data an array of bytes to read from\n     * @param {Object} [options] read options\n     * @return {Object} a bundle or message object\n     */\n    osc.readPacket = function (data, options, offsetState, len) {\n        var dv = osc.dataView(data, data.byteOffset, data.byteLength);\n\n        len = len === undefined ? dv.byteLength : len;\n        offsetState = offsetState || {\n            idx: 0\n        };\n\n        var header = osc.readString(dv, offsetState),\n            firstChar = header[0];\n\n        if (firstChar === \"#\") {\n            return osc.readBundleContents(dv, options, offsetState, len);\n        } else if (firstChar === \"/\") {\n            return osc.readMessageContents(header, dv, options, offsetState);\n        }\n\n        throw new Error(\"The header of an OSC packet didn't contain an OSC address or a #bundle string.\" +\n            \" Header was: \" + header);\n    };\n\n    /**\n     * Writes an OSC packet, which may consist of either of a bundle or a message.\n     *\n     * @param {Object} a bundle or message object\n     * @param {Object} [options] write options\n     * @return {Uint8Array} an array of bytes containing the message\n     */\n    osc.writePacket = function (packet, options) {\n        if (osc.isValidMessage(packet)) {\n            return osc.writeMessage(packet, options);\n        } else if (osc.isValidBundle(packet)) {\n            return osc.writeBundle(packet, options);\n        } else {\n            throw new Error(\"The specified packet was not recognized as a valid OSC message or bundle.\" +\n                \" Packet was: \" + JSON.stringify(packet, null, 2));\n        }\n    };\n\n    // Unsupported, non-API.\n    osc.argumentTypes = {\n        i: {\n            reader: \"readInt32\",\n            writer: \"writeInt32\"\n        },\n        h: {\n            reader: \"readInt64\",\n            writer: \"writeInt64\"\n        },\n        f: {\n            reader: \"readFloat32\",\n            writer: \"writeFloat32\"\n        },\n        s: {\n            reader: \"readString\",\n            writer: \"writeString\"\n        },\n        S: {\n            reader: \"readString\",\n            writer: \"writeString\"\n        },\n        b: {\n            reader: \"readBlob\",\n            writer: \"writeBlob\"\n        },\n        t: {\n            reader: \"readTimeTag\",\n            writer: \"writeTimeTag\"\n        },\n        T: {\n            reader: \"readTrue\"\n        },\n        F: {\n            reader: \"readFalse\"\n        },\n        N: {\n            reader: \"readNull\"\n        },\n        I: {\n            reader: \"readImpulse\"\n        },\n        d: {\n            reader: \"readFloat64\",\n            writer: \"writeFloat64\"\n        },\n        c: {\n            reader: \"readChar32\",\n            writer: \"writeChar32\"\n        },\n        r: {\n            reader: \"readColor\",\n            writer: \"writeColor\"\n        },\n        m: {\n            reader: \"readMIDIBytes\",\n            writer: \"writeMIDIBytes\"\n        },\n        // [] are special cased within read/writeArguments()\n    };\n\n    // Unsupported, non-API function.\n    osc.inferTypeForArgument = function (arg) {\n        var type = typeof arg;\n\n        // TODO: This is freaking hideous.\n        switch (type) {\n            case \"boolean\":\n                return arg ? \"T\" : \"F\";\n            case \"string\":\n                return \"s\";\n            case \"number\":\n                return \"f\";\n            case \"undefined\":\n                return \"N\";\n            case \"object\":\n                if (arg === null) {\n                    return \"N\";\n                } else if (arg instanceof Uint8Array ||\n                    arg instanceof ArrayBuffer) {\n                    return \"b\";\n                } else if (typeof arg.high === \"number\" && typeof arg.low === \"number\") {\n                    return \"h\";\n                }\n                break;\n        }\n\n        throw new Error(\"Can't infer OSC argument type for value: \" +\n            JSON.stringify(arg, null, 2));\n    };\n\n    // Unsupported, non-API function.\n    osc.annotateArguments = function (args) {\n        var annotated = [];\n\n        for (var i = 0; i < args.length; i++) {\n            var arg = args[i],\n                msgArg;\n\n            if (typeof (arg) === \"object\" && arg.type && arg.value !== undefined) {\n                // We've got an explicitly typed argument.\n                msgArg = arg;\n            } else if (osc.isArray(arg)) {\n                // We've got an array of arguments,\n                // so they each need to be inferred and expanded.\n                msgArg = osc.annotateArguments(arg);\n            } else {\n                var oscType = osc.inferTypeForArgument(arg);\n                msgArg = {\n                    type: oscType,\n                    value: arg\n                };\n            }\n\n            annotated.push(msgArg);\n        }\n\n        return annotated;\n    };\n\n    if (osc.isCommonJS) {\n        module.exports = osc;\n    }\n}());\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}