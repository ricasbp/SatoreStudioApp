{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var IsArray,\n    StrictError,\n    TWO_POW_32,\n    UNIX_EPOCH,\n    binpack,\n    getArrayArg,\n    isOscBundleBuffer,\n    makeTimetag,\n    mapBundleList,\n    oscTypeCodes,\n    padding,\n    toOscTypeAndArgs,\n    hasProp = {}.hasOwnProperty;\n  binpack = require(\"binpack\");\n  exports.concat = function (buffers) {\n    var buffer, copyTo, destBuffer, j, k, l, len, len1, len2, sumLength;\n    if (!IsArray(buffers)) {\n      throw new Error(\"concat must take an array of buffers\");\n    }\n    for (j = 0, len = buffers.length; j < len; j++) {\n      buffer = buffers[j];\n      if (!Buffer.isBuffer(buffer)) {\n        throw new Error(\"concat must take an array of buffers\");\n      }\n    }\n    sumLength = 0;\n    for (k = 0, len1 = buffers.length; k < len1; k++) {\n      buffer = buffers[k];\n      sumLength += buffer.length;\n    }\n    destBuffer = new Buffer(sumLength);\n    copyTo = 0;\n    for (l = 0, len2 = buffers.length; l < len2; l++) {\n      buffer = buffers[l];\n      buffer.copy(destBuffer, copyTo);\n      copyTo += buffer.length;\n    }\n    return destBuffer;\n  };\n  exports.toOscString = function (str, strict) {\n    var i, j, nullIndex, ref;\n    if (!(typeof str === \"string\")) {\n      throw new Error(\"can't pack a non-string into an osc-string\");\n    }\n    nullIndex = str.indexOf(\"\\u0000\");\n    if (nullIndex !== -1 && strict) {\n      throw StrictError(\"Can't pack an osc-string that contains NULL characters\");\n    }\n    if (nullIndex !== -1) {\n      str = str.slice(0, nullIndex);\n    }\n    for (i = j = 0, ref = padding(str); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      str += \"\\u0000\";\n    }\n    return new Buffer(str);\n  };\n  exports.splitOscString = function (buffer, strict) {\n    var i, j, nullIndex, rawStr, ref, ref1, rest, splitPoint, str;\n    if (!Buffer.isBuffer(buffer)) {\n      throw StrictError(\"Can't split something that isn't a buffer\");\n    }\n    rawStr = buffer.toString(\"utf8\");\n    nullIndex = rawStr.indexOf(\"\\u0000\");\n    if (nullIndex === -1) {\n      if (strict) {\n        throw new Error(\"All osc-strings must contain a null character\");\n      }\n      return {\n        string: rawStr,\n        rest: new Buffer(0)\n      };\n    }\n    str = rawStr.slice(0, nullIndex);\n    splitPoint = Buffer.byteLength(str) + padding(str);\n    if (strict && splitPoint > buffer.length) {\n      throw StrictError(\"Not enough padding for osc-string\");\n    }\n    if (strict) {\n      for (i = j = ref = Buffer.byteLength(str), ref1 = splitPoint; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n        if (buffer[i] !== 0) {\n          throw StrictError(\"Not enough or incorrect padding for osc-string\");\n        }\n      }\n    }\n    rest = buffer.slice(splitPoint, buffer.length);\n    return {\n      string: str,\n      rest: rest\n    };\n  };\n  exports.splitInteger = function (buffer, type) {\n    var bytes, num, rest, value;\n    if (type == null) {\n      type = \"Int32\";\n    }\n    bytes = binpack[\"pack\" + type](0).length;\n    if (buffer.length < bytes) {\n      throw new Error(\"buffer is not big enough for integer type\");\n    }\n    num = 0;\n    value = binpack[\"unpack\" + type](buffer.slice(0, bytes), \"big\");\n    rest = buffer.slice(bytes, buffer.length);\n    return {\n      integer: value,\n      rest: rest\n    };\n  };\n  exports.splitTimetag = function (buffer) {\n    var a, b, bytes, c, d, fractional, rest, seconds, type;\n    type = \"UInt32\";\n    bytes = binpack[\"pack\" + type](0).length;\n    if (buffer.length < bytes * 2) {\n      throw new Error(\"buffer is not big enough to contain a timetag\");\n    }\n    a = 0;\n    b = bytes;\n    seconds = binpack[\"unpack\" + type](buffer.slice(a, b), \"big\");\n    c = bytes;\n    d = bytes + bytes;\n    fractional = binpack[\"unpack\" + type](buffer.slice(c, d), \"big\");\n    rest = buffer.slice(d, buffer.length);\n    return {\n      timetag: [seconds, fractional],\n      rest: rest\n    };\n  };\n  UNIX_EPOCH = 2208988800;\n  TWO_POW_32 = 4294967296;\n  exports.dateToTimetag = function (date) {\n    return exports.timestampToTimetag(date.getTime() / 1000);\n  };\n  exports.timestampToTimetag = function (secs) {\n    var fracSeconds, wholeSecs;\n    wholeSecs = Math.floor(secs);\n    fracSeconds = secs - wholeSecs;\n    return makeTimetag(wholeSecs, fracSeconds);\n  };\n  exports.timetagToTimestamp = function (timetag) {\n    var seconds;\n    seconds = timetag[0] + exports.ntpToFractionalSeconds(timetag[1]);\n    return seconds - UNIX_EPOCH;\n  };\n  makeTimetag = function (unixseconds, fracSeconds) {\n    var ntpFracs, ntpSecs;\n    ntpSecs = unixseconds + UNIX_EPOCH;\n    ntpFracs = Math.round(TWO_POW_32 * fracSeconds);\n    return [ntpSecs, ntpFracs];\n  };\n  exports.timetagToDate = function (timetag) {\n    var date, dd, fracs, fractional, seconds;\n    seconds = timetag[0], fractional = timetag[1];\n    seconds = seconds - UNIX_EPOCH;\n    fracs = exports.ntpToFractionalSeconds(fractional);\n    date = new Date();\n    date.setTime(seconds * 1000 + fracs * 1000);\n    dd = new Date();\n    dd.setUTCFullYear(date.getUTCFullYear());\n    dd.setUTCMonth(date.getUTCMonth());\n    dd.setUTCDate(date.getUTCDate());\n    dd.setUTCHours(date.getUTCHours());\n    dd.setUTCMinutes(date.getUTCMinutes());\n    dd.setUTCSeconds(date.getUTCSeconds());\n    dd.setUTCMilliseconds(fracs * 1000);\n    return dd;\n  };\n  exports.deltaTimetag = function (seconds, now) {\n    var n;\n    n = (now != null ? now : new Date()) / 1000;\n    return exports.timestampToTimetag(n + seconds);\n  };\n  exports.ntpToFractionalSeconds = function (fracSeconds) {\n    return parseFloat(fracSeconds) / TWO_POW_32;\n  };\n  exports.toTimetagBuffer = function (timetag) {\n    var high, low, type;\n    if (typeof timetag === \"number\") {\n      timetag = exports.timestampToTimetag(timetag);\n    } else if (typeof timetag === \"object\" && \"getTime\" in timetag) {\n      timetag = exports.dateToTimetag(timetag);\n    } else if (timetag.length !== 2) {\n      throw new Error(\"Invalid timetag\" + timetag);\n    }\n    type = \"UInt32\";\n    high = binpack[\"pack\" + type](timetag[0], \"big\");\n    low = binpack[\"pack\" + type](timetag[1], \"big\");\n    return exports.concat([high, low]);\n  };\n  exports.toIntegerBuffer = function (number, type) {\n    if (type == null) {\n      type = \"Int32\";\n    }\n    if (typeof number !== \"number\") {\n      throw new Error(\"cannot pack a non-number into an integer buffer\");\n    }\n    return binpack[\"pack\" + type](number, \"big\");\n  };\n  oscTypeCodes = {\n    s: {\n      representation: \"string\",\n      split: function (buffer, strict) {\n        var split;\n        split = exports.splitOscString(buffer, strict);\n        return {\n          value: split.string,\n          rest: split.rest\n        };\n      },\n      toArg: function (value, strict) {\n        if (typeof value !== \"string\") {\n          throw new Error(\"expected string\");\n        }\n        return exports.toOscString(value, strict);\n      }\n    },\n    i: {\n      representation: \"integer\",\n      split: function (buffer, strict) {\n        var split;\n        split = exports.splitInteger(buffer);\n        return {\n          value: split.integer,\n          rest: split.rest\n        };\n      },\n      toArg: function (value, strict) {\n        if (typeof value !== \"number\") {\n          throw new Error(\"expected number\");\n        }\n        return exports.toIntegerBuffer(value);\n      }\n    },\n    t: {\n      representation: \"timetag\",\n      split: function (buffer, strict) {\n        var split;\n        split = exports.splitTimetag(buffer);\n        return {\n          value: split.timetag,\n          rest: split.rest\n        };\n      },\n      toArg: function (value, strict) {\n        return exports.toTimetagBuffer(value);\n      }\n    },\n    f: {\n      representation: \"float\",\n      split: function (buffer, strict) {\n        return {\n          value: binpack.unpackFloat32(buffer.slice(0, 4), \"big\"),\n          rest: buffer.slice(4, buffer.length)\n        };\n      },\n      toArg: function (value, strict) {\n        if (typeof value !== \"number\") {\n          throw new Error(\"expected number\");\n        }\n        return binpack.packFloat32(value, \"big\");\n      }\n    },\n    d: {\n      representation: \"double\",\n      split: function (buffer, strict) {\n        return {\n          value: binpack.unpackFloat64(buffer.slice(0, 8), \"big\"),\n          rest: buffer.slice(8, buffer.length)\n        };\n      },\n      toArg: function (value, strict) {\n        if (typeof value !== \"number\") {\n          throw new Error(\"expected number\");\n        }\n        return binpack.packFloat64(value, \"big\");\n      }\n    },\n    b: {\n      representation: \"blob\",\n      split: function (buffer, strict) {\n        var length, ref;\n        ref = exports.splitInteger(buffer), length = ref.integer, buffer = ref.rest;\n        return {\n          value: buffer.slice(0, length),\n          rest: buffer.slice(length, buffer.length)\n        };\n      },\n      toArg: function (value, strict) {\n        var size;\n        if (!Buffer.isBuffer(value)) {\n          throw new Error(\"expected node.js Buffer\");\n        }\n        size = exports.toIntegerBuffer(value.length);\n        return exports.concat([size, value]);\n      }\n    },\n    T: {\n      representation: \"true\",\n      split: function (buffer, strict) {\n        return {\n          rest: buffer,\n          value: true\n        };\n      },\n      toArg: function (value, strict) {\n        if (!value && strict) {\n          throw new Error(\"true must be true\");\n        }\n        return new Buffer(0);\n      }\n    },\n    F: {\n      representation: \"false\",\n      split: function (buffer, strict) {\n        return {\n          rest: buffer,\n          value: false\n        };\n      },\n      toArg: function (value, strict) {\n        if (value && strict) {\n          throw new Error(\"false must be false\");\n        }\n        return new Buffer(0);\n      }\n    },\n    N: {\n      representation: \"null\",\n      split: function (buffer, strict) {\n        return {\n          rest: buffer,\n          value: null\n        };\n      },\n      toArg: function (value, strict) {\n        if (value && strict) {\n          throw new Error(\"null must be false\");\n        }\n        return new Buffer(0);\n      }\n    },\n    I: {\n      representation: \"bang\",\n      split: function (buffer, strict) {\n        return {\n          rest: buffer,\n          value: \"bang\"\n        };\n      },\n      toArg: function (value, strict) {\n        return new Buffer(0);\n      }\n    }\n  };\n  exports.oscTypeCodeToTypeString = function (code) {\n    var ref;\n    return (ref = oscTypeCodes[code]) != null ? ref.representation : void 0;\n  };\n  exports.typeStringToOscTypeCode = function (rep) {\n    var code, str;\n    for (code in oscTypeCodes) {\n      if (!hasProp.call(oscTypeCodes, code)) continue;\n      str = oscTypeCodes[code].representation;\n      if (str === rep) {\n        return code;\n      }\n    }\n    return null;\n  };\n  exports.argToTypeCode = function (arg, strict) {\n    var code, value;\n    if ((arg != null ? arg.type : void 0) != null && typeof arg.type === 'string' && (code = exports.typeStringToOscTypeCode(arg.type)) != null) {\n      return code;\n    }\n    value = (arg != null ? arg.value : void 0) != null ? arg.value : arg;\n    if (strict && value == null) {\n      throw new Error('Argument has no value');\n    }\n    if (typeof value === 'string') {\n      return 's';\n    }\n    if (typeof value === 'number') {\n      return 'f';\n    }\n    if (Buffer.isBuffer(value)) {\n      return 'b';\n    }\n    if (typeof value === 'boolean') {\n      if (value) {\n        return 'T';\n      } else {\n        return 'F';\n      }\n    }\n    if (value === null) {\n      return 'N';\n    }\n    throw new Error(\"I don't know what type this is supposed to be.\");\n  };\n  exports.splitOscArgument = function (buffer, type, strict) {\n    var osctype;\n    osctype = exports.typeStringToOscTypeCode(type);\n    if (osctype != null) {\n      return oscTypeCodes[osctype].split(buffer, strict);\n    } else {\n      throw new Error(\"I don't understand how I'm supposed to unpack \" + type);\n    }\n  };\n  exports.toOscArgument = function (value, type, strict) {\n    var osctype;\n    osctype = exports.typeStringToOscTypeCode(type);\n    if (osctype != null) {\n      return oscTypeCodes[osctype].toArg(value, strict);\n    } else {\n      throw new Error(\"I don't know how to pack \" + type);\n    }\n  };\n  exports.fromOscMessage = function (buffer, strict) {\n    var address, arg, args, arrayStack, built, j, len, ref, ref1, type, typeString, types;\n    ref = exports.splitOscString(buffer, strict), address = ref.string, buffer = ref.rest;\n    if (strict && address[0] !== '/') {\n      throw StrictError('addresses must start with /');\n    }\n    if (!buffer.length) {\n      return {\n        address: address,\n        args: []\n      };\n    }\n    ref1 = exports.splitOscString(buffer, strict), types = ref1.string, buffer = ref1.rest;\n    if (types[0] !== ',') {\n      if (strict) {\n        throw StrictError('Argument lists must begin with ,');\n      }\n      return {\n        address: address,\n        args: []\n      };\n    }\n    types = types.slice(1, +types.length + 1 || 9e9);\n    args = [];\n    arrayStack = [args];\n    for (j = 0, len = types.length; j < len; j++) {\n      type = types[j];\n      if (type === '[') {\n        arrayStack.push([]);\n        continue;\n      }\n      if (type === ']') {\n        if (arrayStack.length <= 1) {\n          if (strict) {\n            throw new StrictError(\"Mismatched ']' character.\");\n          }\n        } else {\n          built = arrayStack.pop();\n          arrayStack[arrayStack.length - 1].push({\n            type: 'array',\n            value: built\n          });\n        }\n        continue;\n      }\n      typeString = exports.oscTypeCodeToTypeString(type);\n      if (typeString == null) {\n        throw new Error(\"I don't understand the argument code \" + type);\n      }\n      arg = exports.splitOscArgument(buffer, typeString, strict);\n      if (arg != null) {\n        buffer = arg.rest;\n      }\n      arrayStack[arrayStack.length - 1].push({\n        type: typeString,\n        value: arg != null ? arg.value : void 0\n      });\n    }\n    if (arrayStack.length !== 1 && strict) {\n      throw new StrictError(\"Mismatched '[' character\");\n    }\n    return {\n      address: address,\n      args: args,\n      oscType: \"message\"\n    };\n  };\n  exports.fromOscBundle = function (buffer, strict) {\n    var bundleTag, convertedElems, ref, ref1, timetag;\n    ref = exports.splitOscString(buffer, strict), bundleTag = ref.string, buffer = ref.rest;\n    if (bundleTag !== \"\\#bundle\") {\n      throw new Error(\"osc-bundles must begin with \\#bundle\");\n    }\n    ref1 = exports.splitTimetag(buffer), timetag = ref1.timetag, buffer = ref1.rest;\n    convertedElems = mapBundleList(buffer, function (buffer) {\n      return exports.fromOscPacket(buffer, strict);\n    });\n    return {\n      timetag: timetag,\n      elements: convertedElems,\n      oscType: \"bundle\"\n    };\n  };\n  exports.fromOscPacket = function (buffer, strict) {\n    if (isOscBundleBuffer(buffer, strict)) {\n      return exports.fromOscBundle(buffer, strict);\n    } else {\n      return exports.fromOscMessage(buffer, strict);\n    }\n  };\n  getArrayArg = function (arg) {\n    if (IsArray(arg)) {\n      return arg;\n    } else if ((arg != null ? arg.type : void 0) === \"array\" && IsArray(arg != null ? arg.value : void 0)) {\n      return arg.value;\n    } else if (arg != null && arg.type == null && IsArray(arg.value)) {\n      return arg.value;\n    } else {\n      return null;\n    }\n  };\n  toOscTypeAndArgs = function (argList, strict) {\n    var arg, buff, j, len, oscargs, osctype, ref, thisArgs, thisType, typeCode, value;\n    osctype = \"\";\n    oscargs = [];\n    for (j = 0, len = argList.length; j < len; j++) {\n      arg = argList[j];\n      if (getArrayArg(arg) != null) {\n        ref = toOscTypeAndArgs(getArrayArg(arg), strict), thisType = ref[0], thisArgs = ref[1];\n        osctype += \"[\" + thisType + \"]\";\n        oscargs = oscargs.concat(thisArgs);\n        continue;\n      }\n      typeCode = exports.argToTypeCode(arg, strict);\n      if (typeCode != null) {\n        value = arg != null ? arg.value : void 0;\n        if (value === void 0) {\n          value = arg;\n        }\n        buff = exports.toOscArgument(value, exports.oscTypeCodeToTypeString(typeCode), strict);\n        if (buff != null) {\n          oscargs.push(buff);\n          osctype += typeCode;\n        }\n      }\n    }\n    return [osctype, oscargs];\n  };\n  exports.toOscMessage = function (message, strict) {\n    var address, allArgs, args, old_arg, oscaddr, oscargs, osctype, ref;\n    address = (message != null ? message.address : void 0) != null ? message.address : message;\n    if (typeof address !== \"string\") {\n      throw new Error(\"message must contain an address\");\n    }\n    args = message != null ? message.args : void 0;\n    if (args === void 0) {\n      args = [];\n    }\n    if (!IsArray(args)) {\n      old_arg = args;\n      args = [];\n      args[0] = old_arg;\n    }\n    oscaddr = exports.toOscString(address, strict);\n    ref = toOscTypeAndArgs(args, strict), osctype = ref[0], oscargs = ref[1];\n    osctype = \",\" + osctype;\n    allArgs = exports.concat(oscargs);\n    osctype = exports.toOscString(osctype);\n    return exports.concat([oscaddr, osctype, allArgs]);\n  };\n  exports.toOscBundle = function (bundle, strict) {\n    var allElems, buff, e, elem, elements, elemstr, j, len, oscBundleTag, oscElems, oscTimeTag, ref, ref1, size, timetag;\n    if (strict && (bundle != null ? bundle.timetag : void 0) == null) {\n      throw StrictError(\"bundles must have timetags.\");\n    }\n    timetag = (ref = bundle != null ? bundle.timetag : void 0) != null ? ref : new Date();\n    elements = (ref1 = bundle != null ? bundle.elements : void 0) != null ? ref1 : [];\n    if (!IsArray(elements)) {\n      elemstr = elements;\n      elements = [];\n      elements.push(elemstr);\n    }\n    oscBundleTag = exports.toOscString(\"\\#bundle\");\n    oscTimeTag = exports.toTimetagBuffer(timetag);\n    oscElems = [];\n    for (j = 0, len = elements.length; j < len; j++) {\n      elem = elements[j];\n      try {\n        buff = exports.toOscPacket(elem, strict);\n        size = exports.toIntegerBuffer(buff.length);\n        oscElems.push(exports.concat([size, buff]));\n      } catch (error) {\n        e = error;\n        null;\n      }\n    }\n    allElems = exports.concat(oscElems);\n    return exports.concat([oscBundleTag, oscTimeTag, allElems]);\n  };\n  exports.toOscPacket = function (bundleOrMessage, strict) {\n    if ((bundleOrMessage != null ? bundleOrMessage.oscType : void 0) != null) {\n      if (bundleOrMessage.oscType === \"bundle\") {\n        return exports.toOscBundle(bundleOrMessage, strict);\n      }\n      return exports.toOscMessage(bundleOrMessage, strict);\n    }\n    if ((bundleOrMessage != null ? bundleOrMessage.timetag : void 0) != null || (bundleOrMessage != null ? bundleOrMessage.elements : void 0) != null) {\n      return exports.toOscBundle(bundleOrMessage, strict);\n    }\n    return exports.toOscMessage(bundleOrMessage, strict);\n  };\n  exports.applyMessageTranformerToBundle = function (transform) {\n    return function (buffer) {\n      var bundleTagBuffer, copyIndex, elem, elems, j, k, len, len1, lengthBuff, outBuffer, ref, string, timetagBuffer, totalLength;\n      ref = exports.splitOscString(buffer), string = ref.string, buffer = ref.rest;\n      if (string !== \"\\#bundle\") {\n        throw new Error(\"osc-bundles must begin with \\#bundle\");\n      }\n      bundleTagBuffer = exports.toOscString(string);\n      timetagBuffer = buffer.slice(0, 8);\n      buffer = buffer.slice(8, buffer.length);\n      elems = mapBundleList(buffer, function (buffer) {\n        return exports.applyTransform(buffer, transform, exports.applyMessageTranformerToBundle(transform));\n      });\n      totalLength = bundleTagBuffer.length + timetagBuffer.length;\n      for (j = 0, len = elems.length; j < len; j++) {\n        elem = elems[j];\n        totalLength += 4 + elem.length;\n      }\n      outBuffer = new Buffer(totalLength);\n      bundleTagBuffer.copy(outBuffer, 0);\n      timetagBuffer.copy(outBuffer, bundleTagBuffer.length);\n      copyIndex = bundleTagBuffer.length + timetagBuffer.length;\n      for (k = 0, len1 = elems.length; k < len1; k++) {\n        elem = elems[k];\n        lengthBuff = exports.toIntegerBuffer(elem.length);\n        lengthBuff.copy(outBuffer, copyIndex);\n        copyIndex += 4;\n        elem.copy(outBuffer, copyIndex);\n        copyIndex += elem.length;\n      }\n      return outBuffer;\n    };\n  };\n  exports.applyTransform = function (buffer, mTransform, bundleTransform) {\n    if (bundleTransform == null) {\n      bundleTransform = exports.applyMessageTranformerToBundle(mTransform);\n    }\n    if (isOscBundleBuffer(buffer)) {\n      return bundleTransform(buffer);\n    } else {\n      return mTransform(buffer);\n    }\n  };\n  exports.addressTransform = function (transform) {\n    return function (buffer) {\n      var ref, rest, string;\n      ref = exports.splitOscString(buffer), string = ref.string, rest = ref.rest;\n      string = transform(string);\n      return exports.concat([exports.toOscString(string), rest]);\n    };\n  };\n  exports.messageTransform = function (transform) {\n    return function (buffer) {\n      var message;\n      message = exports.fromOscMessage(buffer);\n      return exports.toOscMessage(transform(message));\n    };\n  };\n  IsArray = Array.isArray;\n  StrictError = function (str) {\n    return new Error(\"Strict Error: \" + str);\n  };\n  padding = function (str) {\n    var bufflength;\n    bufflength = Buffer.byteLength(str);\n    return 4 - bufflength % 4;\n  };\n  isOscBundleBuffer = function (buffer, strict) {\n    var string;\n    string = exports.splitOscString(buffer, strict).string;\n    return string === \"\\#bundle\";\n  };\n  mapBundleList = function (buffer, func) {\n    var e, elem, elems, j, len, nonNullElems, size, thisElemBuffer;\n    elems = function () {\n      var ref, results;\n      results = [];\n      while (buffer.length) {\n        ref = exports.splitInteger(buffer), size = ref.integer, buffer = ref.rest;\n        if (size > buffer.length) {\n          throw new Error(\"Invalid bundle list: size of element is bigger than buffer\");\n        }\n        thisElemBuffer = buffer.slice(0, size);\n        buffer = buffer.slice(size, buffer.length);\n        try {\n          results.push(func(thisElemBuffer));\n        } catch (error) {\n          e = error;\n          results.push(null);\n        }\n      }\n      return results;\n    }();\n    nonNullElems = [];\n    for (j = 0, len = elems.length; j < len; j++) {\n      elem = elems[j];\n      if (elem != null) {\n        nonNullElems.push(elem);\n      }\n    }\n    return nonNullElems;\n  };\n}).call(this);","map":{"version":3,"names":["IsArray","StrictError","TWO_POW_32","UNIX_EPOCH","binpack","getArrayArg","isOscBundleBuffer","makeTimetag","mapBundleList","oscTypeCodes","padding","toOscTypeAndArgs","hasProp","hasOwnProperty","require","exports","concat","buffers","buffer","copyTo","destBuffer","j","k","l","len","len1","len2","sumLength","Error","length","Buffer","isBuffer","copy","toOscString","str","strict","i","nullIndex","ref","indexOf","slice","splitOscString","rawStr","ref1","rest","splitPoint","toString","string","byteLength","splitInteger","type","bytes","num","value","integer","splitTimetag","a","b","c","d","fractional","seconds","timetag","dateToTimetag","date","timestampToTimetag","getTime","secs","fracSeconds","wholeSecs","Math","floor","timetagToTimestamp","ntpToFractionalSeconds","unixseconds","ntpFracs","ntpSecs","round","timetagToDate","dd","fracs","Date","setTime","setUTCFullYear","getUTCFullYear","setUTCMonth","getUTCMonth","setUTCDate","getUTCDate","setUTCHours","getUTCHours","setUTCMinutes","getUTCMinutes","setUTCSeconds","getUTCSeconds","setUTCMilliseconds","deltaTimetag","now","n","parseFloat","toTimetagBuffer","high","low","toIntegerBuffer","number","s","representation","split","toArg","t","f","unpackFloat32","packFloat32","unpackFloat64","packFloat64","size","T","F","N","I","oscTypeCodeToTypeString","code","typeStringToOscTypeCode","rep","call","argToTypeCode","arg","splitOscArgument","osctype","toOscArgument","fromOscMessage","address","args","arrayStack","built","typeString","types","push","pop","oscType","fromOscBundle","bundleTag","convertedElems","fromOscPacket","elements","argList","buff","oscargs","thisArgs","thisType","typeCode","toOscMessage","message","allArgs","old_arg","oscaddr","toOscBundle","bundle","allElems","e","elem","elemstr","oscBundleTag","oscElems","oscTimeTag","toOscPacket","error","bundleOrMessage","applyMessageTranformerToBundle","transform","bundleTagBuffer","copyIndex","elems","lengthBuff","outBuffer","timetagBuffer","totalLength","applyTransform","mTransform","bundleTransform","addressTransform","messageTransform","Array","isArray","bufflength","func","nonNullElems","thisElemBuffer","results"],"sources":["C:/Users/tmart/Desktop/Dissertacao/TourOfHeroes/tour-of-heroes-osc.js/tour-of-heroes/node_modules/osc-min/lib/osc-utilities.js"],"sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function() {\n  var IsArray, StrictError, TWO_POW_32, UNIX_EPOCH, binpack, getArrayArg, isOscBundleBuffer, makeTimetag, mapBundleList, oscTypeCodes, padding, toOscTypeAndArgs,\n    hasProp = {}.hasOwnProperty;\n\n  binpack = require(\"binpack\");\n\n  exports.concat = function(buffers) {\n    var buffer, copyTo, destBuffer, j, k, l, len, len1, len2, sumLength;\n    if (!IsArray(buffers)) {\n      throw new Error(\"concat must take an array of buffers\");\n    }\n    for (j = 0, len = buffers.length; j < len; j++) {\n      buffer = buffers[j];\n      if (!Buffer.isBuffer(buffer)) {\n        throw new Error(\"concat must take an array of buffers\");\n      }\n    }\n    sumLength = 0;\n    for (k = 0, len1 = buffers.length; k < len1; k++) {\n      buffer = buffers[k];\n      sumLength += buffer.length;\n    }\n    destBuffer = new Buffer(sumLength);\n    copyTo = 0;\n    for (l = 0, len2 = buffers.length; l < len2; l++) {\n      buffer = buffers[l];\n      buffer.copy(destBuffer, copyTo);\n      copyTo += buffer.length;\n    }\n    return destBuffer;\n  };\n\n  exports.toOscString = function(str, strict) {\n    var i, j, nullIndex, ref;\n    if (!(typeof str === \"string\")) {\n      throw new Error(\"can't pack a non-string into an osc-string\");\n    }\n    nullIndex = str.indexOf(\"\\u0000\");\n    if (nullIndex !== -1 && strict) {\n      throw StrictError(\"Can't pack an osc-string that contains NULL characters\");\n    }\n    if (nullIndex !== -1) {\n      str = str.slice(0, nullIndex);\n    }\n    for (i = j = 0, ref = padding(str); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      str += \"\\u0000\";\n    }\n    return new Buffer(str);\n  };\n\n  exports.splitOscString = function(buffer, strict) {\n    var i, j, nullIndex, rawStr, ref, ref1, rest, splitPoint, str;\n    if (!Buffer.isBuffer(buffer)) {\n      throw StrictError(\"Can't split something that isn't a buffer\");\n    }\n    rawStr = buffer.toString(\"utf8\");\n    nullIndex = rawStr.indexOf(\"\\u0000\");\n    if (nullIndex === -1) {\n      if (strict) {\n        throw new Error(\"All osc-strings must contain a null character\");\n      }\n      return {\n        string: rawStr,\n        rest: new Buffer(0)\n      };\n    }\n    str = rawStr.slice(0, nullIndex);\n    splitPoint = Buffer.byteLength(str) + padding(str);\n    if (strict && splitPoint > buffer.length) {\n      throw StrictError(\"Not enough padding for osc-string\");\n    }\n    if (strict) {\n      for (i = j = ref = Buffer.byteLength(str), ref1 = splitPoint; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n        if (buffer[i] !== 0) {\n          throw StrictError(\"Not enough or incorrect padding for osc-string\");\n        }\n      }\n    }\n    rest = buffer.slice(splitPoint, buffer.length);\n    return {\n      string: str,\n      rest: rest\n    };\n  };\n\n  exports.splitInteger = function(buffer, type) {\n    var bytes, num, rest, value;\n    if (type == null) {\n      type = \"Int32\";\n    }\n    bytes = (binpack[\"pack\" + type](0)).length;\n    if (buffer.length < bytes) {\n      throw new Error(\"buffer is not big enough for integer type\");\n    }\n    num = 0;\n    value = binpack[\"unpack\" + type](buffer.slice(0, bytes), \"big\");\n    rest = buffer.slice(bytes, buffer.length);\n    return {\n      integer: value,\n      rest: rest\n    };\n  };\n\n  exports.splitTimetag = function(buffer) {\n    var a, b, bytes, c, d, fractional, rest, seconds, type;\n    type = \"UInt32\";\n    bytes = (binpack[\"pack\" + type](0)).length;\n    if (buffer.length < (bytes * 2)) {\n      throw new Error(\"buffer is not big enough to contain a timetag\");\n    }\n    a = 0;\n    b = bytes;\n    seconds = binpack[\"unpack\" + type](buffer.slice(a, b), \"big\");\n    c = bytes;\n    d = bytes + bytes;\n    fractional = binpack[\"unpack\" + type](buffer.slice(c, d), \"big\");\n    rest = buffer.slice(d, buffer.length);\n    return {\n      timetag: [seconds, fractional],\n      rest: rest\n    };\n  };\n\n  UNIX_EPOCH = 2208988800;\n\n  TWO_POW_32 = 4294967296;\n\n  exports.dateToTimetag = function(date) {\n    return exports.timestampToTimetag(date.getTime() / 1000);\n  };\n\n  exports.timestampToTimetag = function(secs) {\n    var fracSeconds, wholeSecs;\n    wholeSecs = Math.floor(secs);\n    fracSeconds = secs - wholeSecs;\n    return makeTimetag(wholeSecs, fracSeconds);\n  };\n\n  exports.timetagToTimestamp = function(timetag) {\n    var seconds;\n    seconds = timetag[0] + exports.ntpToFractionalSeconds(timetag[1]);\n    return seconds - UNIX_EPOCH;\n  };\n\n  makeTimetag = function(unixseconds, fracSeconds) {\n    var ntpFracs, ntpSecs;\n    ntpSecs = unixseconds + UNIX_EPOCH;\n    ntpFracs = Math.round(TWO_POW_32 * fracSeconds);\n    return [ntpSecs, ntpFracs];\n  };\n\n  exports.timetagToDate = function(timetag) {\n    var date, dd, fracs, fractional, seconds;\n    seconds = timetag[0], fractional = timetag[1];\n    seconds = seconds - UNIX_EPOCH;\n    fracs = exports.ntpToFractionalSeconds(fractional);\n    date = new Date();\n    date.setTime((seconds * 1000) + (fracs * 1000));\n    dd = new Date();\n    dd.setUTCFullYear(date.getUTCFullYear());\n    dd.setUTCMonth(date.getUTCMonth());\n    dd.setUTCDate(date.getUTCDate());\n    dd.setUTCHours(date.getUTCHours());\n    dd.setUTCMinutes(date.getUTCMinutes());\n    dd.setUTCSeconds(date.getUTCSeconds());\n    dd.setUTCMilliseconds(fracs * 1000);\n    return dd;\n  };\n\n  exports.deltaTimetag = function(seconds, now) {\n    var n;\n    n = (now != null ? now : new Date()) / 1000;\n    return exports.timestampToTimetag(n + seconds);\n  };\n\n  exports.ntpToFractionalSeconds = function(fracSeconds) {\n    return parseFloat(fracSeconds) / TWO_POW_32;\n  };\n\n  exports.toTimetagBuffer = function(timetag) {\n    var high, low, type;\n    if (typeof timetag === \"number\") {\n      timetag = exports.timestampToTimetag(timetag);\n    } else if (typeof timetag === \"object\" && (\"getTime\" in timetag)) {\n      timetag = exports.dateToTimetag(timetag);\n    } else if (timetag.length !== 2) {\n      throw new Error(\"Invalid timetag\" + timetag);\n    }\n    type = \"UInt32\";\n    high = binpack[\"pack\" + type](timetag[0], \"big\");\n    low = binpack[\"pack\" + type](timetag[1], \"big\");\n    return exports.concat([high, low]);\n  };\n\n  exports.toIntegerBuffer = function(number, type) {\n    if (type == null) {\n      type = \"Int32\";\n    }\n    if (typeof number !== \"number\") {\n      throw new Error(\"cannot pack a non-number into an integer buffer\");\n    }\n    return binpack[\"pack\" + type](number, \"big\");\n  };\n\n  oscTypeCodes = {\n    s: {\n      representation: \"string\",\n      split: function(buffer, strict) {\n        var split;\n        split = exports.splitOscString(buffer, strict);\n        return {\n          value: split.string,\n          rest: split.rest\n        };\n      },\n      toArg: function(value, strict) {\n        if (typeof value !== \"string\") {\n          throw new Error(\"expected string\");\n        }\n        return exports.toOscString(value, strict);\n      }\n    },\n    i: {\n      representation: \"integer\",\n      split: function(buffer, strict) {\n        var split;\n        split = exports.splitInteger(buffer);\n        return {\n          value: split.integer,\n          rest: split.rest\n        };\n      },\n      toArg: function(value, strict) {\n        if (typeof value !== \"number\") {\n          throw new Error(\"expected number\");\n        }\n        return exports.toIntegerBuffer(value);\n      }\n    },\n    t: {\n      representation: \"timetag\",\n      split: function(buffer, strict) {\n        var split;\n        split = exports.splitTimetag(buffer);\n        return {\n          value: split.timetag,\n          rest: split.rest\n        };\n      },\n      toArg: function(value, strict) {\n        return exports.toTimetagBuffer(value);\n      }\n    },\n    f: {\n      representation: \"float\",\n      split: function(buffer, strict) {\n        return {\n          value: binpack.unpackFloat32(buffer.slice(0, 4), \"big\"),\n          rest: buffer.slice(4, buffer.length)\n        };\n      },\n      toArg: function(value, strict) {\n        if (typeof value !== \"number\") {\n          throw new Error(\"expected number\");\n        }\n        return binpack.packFloat32(value, \"big\");\n      }\n    },\n    d: {\n      representation: \"double\",\n      split: function(buffer, strict) {\n        return {\n          value: binpack.unpackFloat64(buffer.slice(0, 8), \"big\"),\n          rest: buffer.slice(8, buffer.length)\n        };\n      },\n      toArg: function(value, strict) {\n        if (typeof value !== \"number\") {\n          throw new Error(\"expected number\");\n        }\n        return binpack.packFloat64(value, \"big\");\n      }\n    },\n    b: {\n      representation: \"blob\",\n      split: function(buffer, strict) {\n        var length, ref;\n        ref = exports.splitInteger(buffer), length = ref.integer, buffer = ref.rest;\n        return {\n          value: buffer.slice(0, length),\n          rest: buffer.slice(length, buffer.length)\n        };\n      },\n      toArg: function(value, strict) {\n        var size;\n        if (!Buffer.isBuffer(value)) {\n          throw new Error(\"expected node.js Buffer\");\n        }\n        size = exports.toIntegerBuffer(value.length);\n        return exports.concat([size, value]);\n      }\n    },\n    T: {\n      representation: \"true\",\n      split: function(buffer, strict) {\n        return {\n          rest: buffer,\n          value: true\n        };\n      },\n      toArg: function(value, strict) {\n        if (!value && strict) {\n          throw new Error(\"true must be true\");\n        }\n        return new Buffer(0);\n      }\n    },\n    F: {\n      representation: \"false\",\n      split: function(buffer, strict) {\n        return {\n          rest: buffer,\n          value: false\n        };\n      },\n      toArg: function(value, strict) {\n        if (value && strict) {\n          throw new Error(\"false must be false\");\n        }\n        return new Buffer(0);\n      }\n    },\n    N: {\n      representation: \"null\",\n      split: function(buffer, strict) {\n        return {\n          rest: buffer,\n          value: null\n        };\n      },\n      toArg: function(value, strict) {\n        if (value && strict) {\n          throw new Error(\"null must be false\");\n        }\n        return new Buffer(0);\n      }\n    },\n    I: {\n      representation: \"bang\",\n      split: function(buffer, strict) {\n        return {\n          rest: buffer,\n          value: \"bang\"\n        };\n      },\n      toArg: function(value, strict) {\n        return new Buffer(0);\n      }\n    }\n  };\n\n  exports.oscTypeCodeToTypeString = function(code) {\n    var ref;\n    return (ref = oscTypeCodes[code]) != null ? ref.representation : void 0;\n  };\n\n  exports.typeStringToOscTypeCode = function(rep) {\n    var code, str;\n    for (code in oscTypeCodes) {\n      if (!hasProp.call(oscTypeCodes, code)) continue;\n      str = oscTypeCodes[code].representation;\n      if (str === rep) {\n        return code;\n      }\n    }\n    return null;\n  };\n\n  exports.argToTypeCode = function(arg, strict) {\n    var code, value;\n    if (((arg != null ? arg.type : void 0) != null) && (typeof arg.type === 'string') && ((code = exports.typeStringToOscTypeCode(arg.type)) != null)) {\n      return code;\n    }\n    value = (arg != null ? arg.value : void 0) != null ? arg.value : arg;\n    if (strict && (value == null)) {\n      throw new Error('Argument has no value');\n    }\n    if (typeof value === 'string') {\n      return 's';\n    }\n    if (typeof value === 'number') {\n      return 'f';\n    }\n    if (Buffer.isBuffer(value)) {\n      return 'b';\n    }\n    if (typeof value === 'boolean') {\n      if (value) {\n        return 'T';\n      } else {\n        return 'F';\n      }\n    }\n    if (value === null) {\n      return 'N';\n    }\n    throw new Error(\"I don't know what type this is supposed to be.\");\n  };\n\n  exports.splitOscArgument = function(buffer, type, strict) {\n    var osctype;\n    osctype = exports.typeStringToOscTypeCode(type);\n    if (osctype != null) {\n      return oscTypeCodes[osctype].split(buffer, strict);\n    } else {\n      throw new Error(\"I don't understand how I'm supposed to unpack \" + type);\n    }\n  };\n\n  exports.toOscArgument = function(value, type, strict) {\n    var osctype;\n    osctype = exports.typeStringToOscTypeCode(type);\n    if (osctype != null) {\n      return oscTypeCodes[osctype].toArg(value, strict);\n    } else {\n      throw new Error(\"I don't know how to pack \" + type);\n    }\n  };\n\n  exports.fromOscMessage = function(buffer, strict) {\n    var address, arg, args, arrayStack, built, j, len, ref, ref1, type, typeString, types;\n    ref = exports.splitOscString(buffer, strict), address = ref.string, buffer = ref.rest;\n    if (strict && address[0] !== '/') {\n      throw StrictError('addresses must start with /');\n    }\n    if (!buffer.length) {\n      return {\n        address: address,\n        args: []\n      };\n    }\n    ref1 = exports.splitOscString(buffer, strict), types = ref1.string, buffer = ref1.rest;\n    if (types[0] !== ',') {\n      if (strict) {\n        throw StrictError('Argument lists must begin with ,');\n      }\n      return {\n        address: address,\n        args: []\n      };\n    }\n    types = types.slice(1, +types.length + 1 || 9e9);\n    args = [];\n    arrayStack = [args];\n    for (j = 0, len = types.length; j < len; j++) {\n      type = types[j];\n      if (type === '[') {\n        arrayStack.push([]);\n        continue;\n      }\n      if (type === ']') {\n        if (arrayStack.length <= 1) {\n          if (strict) {\n            throw new StrictError(\"Mismatched ']' character.\");\n          }\n        } else {\n          built = arrayStack.pop();\n          arrayStack[arrayStack.length - 1].push({\n            type: 'array',\n            value: built\n          });\n        }\n        continue;\n      }\n      typeString = exports.oscTypeCodeToTypeString(type);\n      if (typeString == null) {\n        throw new Error(\"I don't understand the argument code \" + type);\n      }\n      arg = exports.splitOscArgument(buffer, typeString, strict);\n      if (arg != null) {\n        buffer = arg.rest;\n      }\n      arrayStack[arrayStack.length - 1].push({\n        type: typeString,\n        value: arg != null ? arg.value : void 0\n      });\n    }\n    if (arrayStack.length !== 1 && strict) {\n      throw new StrictError(\"Mismatched '[' character\");\n    }\n    return {\n      address: address,\n      args: args,\n      oscType: \"message\"\n    };\n  };\n\n  exports.fromOscBundle = function(buffer, strict) {\n    var bundleTag, convertedElems, ref, ref1, timetag;\n    ref = exports.splitOscString(buffer, strict), bundleTag = ref.string, buffer = ref.rest;\n    if (bundleTag !== \"\\#bundle\") {\n      throw new Error(\"osc-bundles must begin with \\#bundle\");\n    }\n    ref1 = exports.splitTimetag(buffer), timetag = ref1.timetag, buffer = ref1.rest;\n    convertedElems = mapBundleList(buffer, function(buffer) {\n      return exports.fromOscPacket(buffer, strict);\n    });\n    return {\n      timetag: timetag,\n      elements: convertedElems,\n      oscType: \"bundle\"\n    };\n  };\n\n  exports.fromOscPacket = function(buffer, strict) {\n    if (isOscBundleBuffer(buffer, strict)) {\n      return exports.fromOscBundle(buffer, strict);\n    } else {\n      return exports.fromOscMessage(buffer, strict);\n    }\n  };\n\n  getArrayArg = function(arg) {\n    if (IsArray(arg)) {\n      return arg;\n    } else if (((arg != null ? arg.type : void 0) === \"array\") && (IsArray(arg != null ? arg.value : void 0))) {\n      return arg.value;\n    } else if ((arg != null) && (arg.type == null) && (IsArray(arg.value))) {\n      return arg.value;\n    } else {\n      return null;\n    }\n  };\n\n  toOscTypeAndArgs = function(argList, strict) {\n    var arg, buff, j, len, oscargs, osctype, ref, thisArgs, thisType, typeCode, value;\n    osctype = \"\";\n    oscargs = [];\n    for (j = 0, len = argList.length; j < len; j++) {\n      arg = argList[j];\n      if ((getArrayArg(arg)) != null) {\n        ref = toOscTypeAndArgs(getArrayArg(arg), strict), thisType = ref[0], thisArgs = ref[1];\n        osctype += \"[\" + thisType + \"]\";\n        oscargs = oscargs.concat(thisArgs);\n        continue;\n      }\n      typeCode = exports.argToTypeCode(arg, strict);\n      if (typeCode != null) {\n        value = arg != null ? arg.value : void 0;\n        if (value === void 0) {\n          value = arg;\n        }\n        buff = exports.toOscArgument(value, exports.oscTypeCodeToTypeString(typeCode), strict);\n        if (buff != null) {\n          oscargs.push(buff);\n          osctype += typeCode;\n        }\n      }\n    }\n    return [osctype, oscargs];\n  };\n\n  exports.toOscMessage = function(message, strict) {\n    var address, allArgs, args, old_arg, oscaddr, oscargs, osctype, ref;\n    address = (message != null ? message.address : void 0) != null ? message.address : message;\n    if (typeof address !== \"string\") {\n      throw new Error(\"message must contain an address\");\n    }\n    args = message != null ? message.args : void 0;\n    if (args === void 0) {\n      args = [];\n    }\n    if (!IsArray(args)) {\n      old_arg = args;\n      args = [];\n      args[0] = old_arg;\n    }\n    oscaddr = exports.toOscString(address, strict);\n    ref = toOscTypeAndArgs(args, strict), osctype = ref[0], oscargs = ref[1];\n    osctype = \",\" + osctype;\n    allArgs = exports.concat(oscargs);\n    osctype = exports.toOscString(osctype);\n    return exports.concat([oscaddr, osctype, allArgs]);\n  };\n\n  exports.toOscBundle = function(bundle, strict) {\n    var allElems, buff, e, elem, elements, elemstr, j, len, oscBundleTag, oscElems, oscTimeTag, ref, ref1, size, timetag;\n    if (strict && ((bundle != null ? bundle.timetag : void 0) == null)) {\n      throw StrictError(\"bundles must have timetags.\");\n    }\n    timetag = (ref = bundle != null ? bundle.timetag : void 0) != null ? ref : new Date();\n    elements = (ref1 = bundle != null ? bundle.elements : void 0) != null ? ref1 : [];\n    if (!IsArray(elements)) {\n      elemstr = elements;\n      elements = [];\n      elements.push(elemstr);\n    }\n    oscBundleTag = exports.toOscString(\"\\#bundle\");\n    oscTimeTag = exports.toTimetagBuffer(timetag);\n    oscElems = [];\n    for (j = 0, len = elements.length; j < len; j++) {\n      elem = elements[j];\n      try {\n        buff = exports.toOscPacket(elem, strict);\n        size = exports.toIntegerBuffer(buff.length);\n        oscElems.push(exports.concat([size, buff]));\n      } catch (error) {\n        e = error;\n        null;\n      }\n    }\n    allElems = exports.concat(oscElems);\n    return exports.concat([oscBundleTag, oscTimeTag, allElems]);\n  };\n\n  exports.toOscPacket = function(bundleOrMessage, strict) {\n    if ((bundleOrMessage != null ? bundleOrMessage.oscType : void 0) != null) {\n      if (bundleOrMessage.oscType === \"bundle\") {\n        return exports.toOscBundle(bundleOrMessage, strict);\n      }\n      return exports.toOscMessage(bundleOrMessage, strict);\n    }\n    if (((bundleOrMessage != null ? bundleOrMessage.timetag : void 0) != null) || ((bundleOrMessage != null ? bundleOrMessage.elements : void 0) != null)) {\n      return exports.toOscBundle(bundleOrMessage, strict);\n    }\n    return exports.toOscMessage(bundleOrMessage, strict);\n  };\n\n  exports.applyMessageTranformerToBundle = function(transform) {\n    return function(buffer) {\n      var bundleTagBuffer, copyIndex, elem, elems, j, k, len, len1, lengthBuff, outBuffer, ref, string, timetagBuffer, totalLength;\n      ref = exports.splitOscString(buffer), string = ref.string, buffer = ref.rest;\n      if (string !== \"\\#bundle\") {\n        throw new Error(\"osc-bundles must begin with \\#bundle\");\n      }\n      bundleTagBuffer = exports.toOscString(string);\n      timetagBuffer = buffer.slice(0, 8);\n      buffer = buffer.slice(8, buffer.length);\n      elems = mapBundleList(buffer, function(buffer) {\n        return exports.applyTransform(buffer, transform, exports.applyMessageTranformerToBundle(transform));\n      });\n      totalLength = bundleTagBuffer.length + timetagBuffer.length;\n      for (j = 0, len = elems.length; j < len; j++) {\n        elem = elems[j];\n        totalLength += 4 + elem.length;\n      }\n      outBuffer = new Buffer(totalLength);\n      bundleTagBuffer.copy(outBuffer, 0);\n      timetagBuffer.copy(outBuffer, bundleTagBuffer.length);\n      copyIndex = bundleTagBuffer.length + timetagBuffer.length;\n      for (k = 0, len1 = elems.length; k < len1; k++) {\n        elem = elems[k];\n        lengthBuff = exports.toIntegerBuffer(elem.length);\n        lengthBuff.copy(outBuffer, copyIndex);\n        copyIndex += 4;\n        elem.copy(outBuffer, copyIndex);\n        copyIndex += elem.length;\n      }\n      return outBuffer;\n    };\n  };\n\n  exports.applyTransform = function(buffer, mTransform, bundleTransform) {\n    if (bundleTransform == null) {\n      bundleTransform = exports.applyMessageTranformerToBundle(mTransform);\n    }\n    if (isOscBundleBuffer(buffer)) {\n      return bundleTransform(buffer);\n    } else {\n      return mTransform(buffer);\n    }\n  };\n\n  exports.addressTransform = function(transform) {\n    return function(buffer) {\n      var ref, rest, string;\n      ref = exports.splitOscString(buffer), string = ref.string, rest = ref.rest;\n      string = transform(string);\n      return exports.concat([exports.toOscString(string), rest]);\n    };\n  };\n\n  exports.messageTransform = function(transform) {\n    return function(buffer) {\n      var message;\n      message = exports.fromOscMessage(buffer);\n      return exports.toOscMessage(transform(message));\n    };\n  };\n\n  IsArray = Array.isArray;\n\n  StrictError = function(str) {\n    return new Error(\"Strict Error: \" + str);\n  };\n\n  padding = function(str) {\n    var bufflength;\n    bufflength = Buffer.byteLength(str);\n    return 4 - (bufflength % 4);\n  };\n\n  isOscBundleBuffer = function(buffer, strict) {\n    var string;\n    string = exports.splitOscString(buffer, strict).string;\n    return string === \"\\#bundle\";\n  };\n\n  mapBundleList = function(buffer, func) {\n    var e, elem, elems, j, len, nonNullElems, size, thisElemBuffer;\n    elems = (function() {\n      var ref, results;\n      results = [];\n      while (buffer.length) {\n        ref = exports.splitInteger(buffer), size = ref.integer, buffer = ref.rest;\n        if (size > buffer.length) {\n          throw new Error(\"Invalid bundle list: size of element is bigger than buffer\");\n        }\n        thisElemBuffer = buffer.slice(0, size);\n        buffer = buffer.slice(size, buffer.length);\n        try {\n          results.push(func(thisElemBuffer));\n        } catch (error) {\n          e = error;\n          results.push(null);\n        }\n      }\n      return results;\n    })();\n    nonNullElems = [];\n    for (j = 0, len = elems.length; j < len; j++) {\n      elem = elems[j];\n      if (elem != null) {\n        nonNullElems.push(elem);\n      }\n    }\n    return nonNullElems;\n  };\n\n}).call(this);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}